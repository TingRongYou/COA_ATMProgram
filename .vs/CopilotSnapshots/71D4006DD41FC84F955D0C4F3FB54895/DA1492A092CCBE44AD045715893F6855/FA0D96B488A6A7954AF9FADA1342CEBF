INCLUDE Irvine32.inc

.DATA
    ;-----------Welcome & Exit Message-----------
    welcomeMessage BYTE "+-----Welcome to PREMIER ATM SYSTEM!-----+", 0  
    exitMessage BYTE "+-----Thanks for using PREMIER ATM SYSTEM, have a nice day!-----+", 0

    ;-----------Date and Time Variables-----------
    sysTime SYSTEMTIME <>         ; To store the current date/time
    msg1 BYTE "Current Date and Time (24-Hour Format): ", 0
    colon BYTE ":", 0
    dash BYTE "-", 0
    space BYTE " ", 0
    goodMorningMsg BYTE "Good Morning! ", 0       ; Message for morning
    goodAfternoonMsg BYTE "Good Afternoon! ", 0    ; Message for afternoon
    goodNightMsg BYTE "Good Night! ", 0             ; Message for night

    ;-----------Variable for GetCardNum------------
    promptCard1 BYTE "Enter first 8-digit credit card number: ", 0
    promptCard2 BYTE "Enter second 8-digit credit card number: ", 0
    userCardInput1 DWORD ?
    userCardInput2 DWORD ?
    validCardInput1 DWORD 11112222
    validCardInput2 DWORD 33334444
    validCCMessage BYTE ">>> Valid Credit Card!", 0
    invalidCCMessage BYTE ">>> Invalid Credit Card!", 0

    ;-----------Variable for GetPinNum------------
    promptPin BYTE "Enter your PIN Number: ", 0
    userPinInput DWORD ?
    validPinInput DWORD 718111
    validPinMessage BYTE ">>> Valid PIN Number!", 0
    invalidPinMessage BYTE ">>> Invalid PIN Number!", 0
    asterisk BYTE "*", 0

    ;------------Main Menu-------------
    accessGranted BYTE ">>> Access Granted! Please enjoy using our system!", 0Dh, 0Ah, 0
    mainMenuOptions BYTE "+---------Main Menu---------+", 0Dh, 0Ah
                    BYTE "1. Deposit", 0Dh, 0Ah                     ;0Dh means carriage return
                    BYTE "2. Withdraw", 0Dh, 0Ah                   ;0Ah means linefeed
                    BYTE "3. Check Balance", 0Dh, 0Ah  
                    BYTE "4. Currency Conversion", 0Dh, 0Ah
                    BYTE "5. Future Value Calculation", 0Dh, 0Ah
                    BYTE "6. Rewards", 0Dh, 0Ah
                    BYTE "7. Exit", 0Dh, 0Ah, 0                   ;0 means null terminator, marking the end of the string 

    ;------------Handle Main Menu Choice----------
    mainMenuMessage BYTE "Enter your choice(1-7): ", 0
    mainMenuChoice DWORD ?

    ;-------------Withdrawal---------------
    withdrawTitle BYTE "+---------Money Withdrawal---------+", 0
    promptWithdrawalAmount BYTE "Enter withdrawal amount: ", 0
    notSufficientBalance BYTE ">>> Insufficient balance amount! Please Enter again", 0
    confirmWithdraw BYTE "Confirm Withdrawal (Y/N)? ", 0
    invalidWithdrawMessage BYTE ">>> Invalid withdrawal amount. Please enter a positive value.", 0
    invalidIntegerMessage BYTE ">>> Invalid input. Please enter a valid integer.", 0

    bill100Msg BYTE "RM100 bills: ", 0
    bill50Msg BYTE "RM50 bills: ", 0
    bill20Msg BYTE "RM20 bills: ", 0
    bill10Msg BYTE "RM10 bills: ", 0
    bill5Msg  BYTE "RM5 bills: ", 0
    bill1Msg  BYTE "RM1 bills: ", 0

    bill100 DWORD ?
    bill50 DWORD ?
    bill20 DWORD ?
    bill10 DWORD ?
    bill5 DWORD ?
    bill1 DWORD ?

    ;--------Future Value Calculation------
    futureValueCalTitle BYTE "+---------Future Value Calculator---------+", 0
    promptDeposit     BYTE "Enter yearly regular deposit (RM): ", 0
    promptRate        BYTE "Enter annual interest rate (%) [1% / 2% ...] : ", 0
    promptYears       BYTE "Enter number of years: ", 0
    resultMsg         BYTE ">>> Future Value: ", 0
    overflowMessage   BYTE ">>> Overflow Error! Result too large.", 0
    errorNegative BYTE ">>> Invalid input. Please enter a positive value.", 0
    errorInvalidOption BYTE ">>>Invalid option. Please enter y or n.", 0

    deposit           DWORD ?         ; Yearly deposit (P)
    interestRate      DWORD ?         ; Interest rate (as a whole number, e.g., 5 for 5%)
    years             DWORD ?         ; Number of years (n)
    futureValue       DWORD 0         ; Final accumulated amount (FV) in sen
    oneHundred        DWORD 100       ; Scaling factor for percentage calculations
    oneThousand       DWORD 1000      ; More precise scaling factor for division

    ;-------------Error Message-------------
    errorMessage BYTE ">>> Invalid option, Please try again!", 0

    ;-------------Balance-------------
    checkBalanceTitle BYTE "+---------Check Balance---------+", 0
    balanceMessage BYTE ">>> Your current account balance are: ", 0
    balanceUnit BYTE "RM", 0
    balance DWORD 12345678 

    ;-------------Continue?-------------
    continueMessage BYTE "Do you want to continue(y/n)?: ", 0
    continueOption BYTE ?

    ;-------------Print Receipt?-------------
    printRequestMessage BYTE "Do you want to print receipt(y/n)?: ", 0
    printOption BYTE ?

    ;-------------Receipt-------------
    receiptHeader BYTE "+--------------------------+", 0Dh, 0Ah
                 BYTE "   PREMIER ATM RECEIPT", 0Dh, 0Ah
                 BYTE "+--------------------------+", 0

    receiptDeposit BYTE "Money Deposited: ", 0
    DepositTotal DWORD 0

    receiptWithdraw BYTE "Money Withdrawed: ", 0
    WithdrawTotal DWORD 0

    receiptBalance BYTE "Balance: ", 0

    receiptFooter BYTE "+--------------------------+", 0
    spacingToRight BYTE "          ", 0  

    ;-------------Reperform Any Function?-------------
    redoMessage BYTE "Do you want to perform any other functions(y/n)?: ", 0
    redoOption BYTE ?

    ;-------------Deposit-------------
    depositTitle BYTE "+---------Money Deposit---------+", 0
    getDeposit BYTE "Enter amount to deposit: ", 0
    confirmDeposit BYTE "Confirm deposit (Y/N)? ", 0
    invalidDepositMessage BYTE ">>> Invalid deposit amount. Please enter a positive value.", 0
    depositAmount DWORD 0         ; Stores deposit amount entered by user

    ;-------------Reward-------------
    rewardTitle BYTE "+---------Reward Points---------+", 0
    rewardRate DWORD 5
    conversionFactor DWORD 10
    rewardPoints DWORD 0
    rewardPointsMessage BYTE "Reward Points: ", 0
    points BYTE " points", 0
    rewardMessage   db "Your current reward points: ", 0
    currentPointsMsg db "Points: ", 0

    ;-------------Reward Menu-------------
    rewardMenu BYTE  "+---------Reward Menu---------+", 0Dh, 0Ah
                    BYTE "1. Redeem Points", 0Dh, 0Ah                     ;0Dh means carriage return
                    BYTE "2. Estimate Future Points", 0Dh, 0Ah                   ;0Ah means linefeed
                    BYTE "3. Back", 0Dh, 0Ah 
                    BYTE "4. Exit", 0Dh, 0Ah, 0       
    rewardMenuMsg BYTE "Enter your choice(1-4): ", 0
    rewardMenuChoice DWORD ?

    ;-------------Reward Points Menu-------------
    redeemPointsMenu BYTE  "+---------Redeem Points---------+", 0Dh, 0Ah
                    BYTE "1. Point to Money (10 points needed)", 0Dh, 0Ah                     ;0Dh means carriage return
                    BYTE "2. Voucher Code (30 points needed)", 0Dh, 0Ah                   ;0Ah means linefeed
                    BYTE "3. Back", 0Dh, 0Ah                   
                    BYTE "4. Exit", 0Dh, 0Ah, 0 
    redeemPointsMsg BYTE "Enter your choice(1-4): ", 0
    redeemPointChoice DWORD ?
    confirmRedeemMoney BYTE "Confirm redeeming points for money (Y/N)? ", 0
    moneyRedeemSuccess BYTE ">>> Points redeemed successfully! Money credited to your account.", 0
    moneyRedeemMsg BYTE ">>> Money redeemed: ", 0
    rewardPointsDeducted BYTE ">>> Points deducted: ", 0
    moneyRedeemAmount DWORD 0
    extraPointMsg1 BYTE ">>> Extra ", 0
    extraPointMsg2 BYTE " points has be returned.", 0

    ;-------------PointToMoney-------------
    PointToMoneyMsg BYTE "How many points do you want to redeem?: ", 0
    PointToMoneyAmount DWORD ?
    leftoverPoints DWORD 0
    insufficientRewardPoint BYTE ">>> Insufficient reward point. Please try again.", 0

    ;-------------Voucher Code-------------
    voucherCodeMenu BYTE  "+---------Voucher Code---------+", 0Dh, 0Ah
                    BYTE "1. BACX2033 (Discount 30%)", 0Dh, 0Ah                     ;0Dh means carriage return
                    BYTE "2. BADX3033 (Discount 30%)", 0Dh, 0Ah                   ;0Ah means linefeed
                    BYTE "3. BAJG1020 (CashBack RM10)", 0Dh, 0Ah       
                    BYTE "4. Back", 0Dh, 0Ah
                    BYTE "5. Exit", 0Dh, 0Ah, 0 

    voucherCodeMsg BYTE "Enter your choice(1-5): ", 0
    voucherCodeChoice DWORD ?
    voucherRedeemSuccess BYTE ">>> Voucher code redeemed successfully!", 0
    voucherCode1 BYTE ">>> Voucher code: BACX2033 (Discount 30%)", 0
    voucherCode2 BYTE ">>> Voucher code: BADX3033 (Discount 30%)", 0
    voucherCode3 BYTE ">>> Voucher code: BAJG1020 (CashBack RM10)", 0
    confirmVoucher BYTE "Confirm voucher code (Y/N)? ", 0

    ;-------------Points Estimation-------------
    futureEstimateTitle   BYTE "+---------Future Reward Estimator---------+", 0
    promptMonthlyDeposit  BYTE "Enter estimated monthly deposit (RM): ", 0
    promptMonths          BYTE "Enter number of months: ", 0
    estimatedPointsMsg             BYTE ">>> Estimated reward points after that period: ", 0

    monthlyDeposit        DWORD ?
    numberOfMonths        DWORD ?
    estimatedPoints       DWORD ?

     ;-------------Currency-------------
    ; Display Currency Title 
    currencyTitle BYTE "+---------Currency Conversion---------+", 0
    ; Currency Selection
    currencyMenuText BYTE "Select Currency:" ,0Dh,0Ah
                     BYTE "1 - USD" ,0Dh,0Ah
                     BYTE "2 - EUR" ,0Dh,0Ah
                     BYTE "3 - GBP" ,0Dh,0Ah
                     BYTE "4 - JPY" ,0Dh,0Ah
                     BYTE "5 - AUD" ,0Dh,0Ah
                     BYTE "6 - Back to Main Menu", 0Dh,0Ah,0
    
    ; Get currency choice from user
    promptCurrency BYTE "Enter your currency type (1-6): ", 0
    chosenCurrency DWORD ?
    currencyCents  DWORD 0

    ; Messages (you need to define these)
    mainMenuMessage2 BYTE "Back at main menu...", 0
    errorMessage2 BYTE "Invalid input. Please try again.", 0
    insufficientFundsMessage BYTE "Insufficient funds for this conversion. Please enter a smaller amount.",0

     ; Withdrawal Amount
    promptAmount BYTE "Enter withdrawal amount: ", 0
    withdrawalAmount DWORD ?
    
    Message1 BYTE "Enter withdrawal amount in USD: ",0
    Message2 BYTE "Enter withdrawal amount in EUR: ",0
    Message3 BYTE "Enter withdrawal amount in GBP: ",0
    Message4 BYTE "Enter withdrawal amount in JPY: ",0 
    Message5 BYTE "Enter withdrawal amount in AUD: ",0

    Message6 BYTE "Amount Used: ",0
    Message7 BYTE "Withdrawal Amount: ",0
    Message8 BYTE "Your new balance is ",0

    NewBalance DWORD 0
    Amount DWORD 0
    TotalAmountUSD DWORD 0
    TotalAmountEUR DWORD 0
    TotalAmountGBP DWORD 0
    TotalAmountJPY DWORD 0
    TotalAmountAUD DWORD 0

    ;Unit for currency
    USDUnit BYTE " USD",0
    EURUnit BYTE " EUR",0
    GBPUnit BYTE " GBP",0
    JPYUnit BYTE " JPY",0
    AUDUnit BYTE " AUD",0
    
    ; Exchange Rates (Relative to Local Currency)
    rateUSD DWORD 15
    rateEUR DWORD 8
    rateGBP DWORD 10
    rateJPY DWORD 4
    rateAUD DWORD 6

    initialMenuOptions BYTE "+---------Initial Menu---------+", 0Dh, 0Ah
                          BYTE "1. Register", 0Dh, 0Ah
                          BYTE "2. Login", 0Dh, 0Ah
                          BYTE "3. Exit", 0Dh, 0Ah, 0
    initialMenuPrompt BYTE "Enter your choice (1-3): ", 0
    registerPrompt BYTE "Register a new account:", 0
    usernamePrompt BYTE "Enter username: ", 0
    cardPart1Prompt BYTE "Enter first 8-digit card number: ", 0
    cardPart2Prompt BYTE "Enter second 8-digit card number: ", 0
    pinPrompt BYTE "Enter 6-digit PIN: ", 0
    balancePrompt BYTE "Enter initial balance: ", 0
    registerSuccess BYTE "Registration successful!", 0
    registerFailed BYTE "Registration failed. Please try again.", 0
    loginPrompt BYTE "Login to your account:", 0
    loginSuccess BYTE "Login successful!", 0
    loginFailed BYTE "Login failed. Invalid credentials.", 0

Register PROTO
Login PROTO
WriteToFile PROTO

    registerPrompt BYTE "Register a new account:", 0
    usernamePrompt BY    call InitialMenu
igit card number: ", 0
    cardPart2Prompt BYTE "Enter second 8-digit card number: ", 0
    pinPrompt BYTE "Enter 6-digit PIN: ", 0
    balancePrompt BYTE "Enter initial balance: ", 0
    registerSuccess BYTE "Registration successful!", 0
    registerFailed BYTE "Registration failed. Please try again.", 0
    loginPrompt BYTE "Login to your account:", 0
    loginSuccess BYTE "Login successful!", 0
    loginFailed BYTE "Login failed. Invalid credentials.", 0

    initialMenuOptions BYTE "+---------Initial Menu---------+", 0Dh, 0Ah
                          BYTE "1. Register", 0Dh, 0Ah
                          BYTE "2. Login", 0Dh, 0Ah
                          BYTE "3. Exit", 0Dh, 0Ah, 0
    initialMenuPrompt BYTE "Enter your choice (1-3):InitialMenu PROTO
Register PROTO
Login PROTO
WriteToFile PROTO
 ", 0
    registerPrompt BYTE "Register a new account:", 0
    usernamePrompt BY    call InitialMenu
igit card number: ", 0
    cardPart2Prompt BYTE "Enter second 8-digit card number: ", 0
    pinPrompt BYTE "Enter 6-digit PIN: ", 0
    balancePrompt BYTE "Enter initial balance: ", 0
    registerSuccess BYTE "Registration successful!", 0
    registerFailed BYTE "Registration failed. Please try again.", 0
    loginPrompt BYTE "Login to your account:", 0
    loginSuccess BYTE "Login successful!", 0
    loginFailed BYTE "Login failed. Invalid credentials.", 0

.CODE

;----------Functions Prototype----------
PrintWelcome PROTO
GetCCNum PROTO
GetPinNum PROTO
CheckBalance PROTO
ContinueRequest PROTO
PrintReceiptOption PROTO
FutureValueCalculator PROTO
DepositMoney PROTO 
DisplayMainMenu PROTO
RePerformFunction PROTO
QuitProgram PROTO
InitialMenu PROTO
Register PROTO
Login PROTO
WriteToFile PROTO

;----------Main----------
MAIN PROC
    call PrintWelcome
    call DateTime
    call InitialMenu

    EXIT         
MAIN ENDP

;----------Functions----------
;----------Print Welcome Message----------
PrintWelcome PROC
    mov eax, lightCyan             ; Set text color (choose your color)
    call SetTextColor

    mov edx, OFFSET welcomeMessage ; Load address of welcome message
    call WriteString               ; Print the message
    call Crlf
    call Crlf

    ; Optional: reset text color after welcome
    mov eax, white
    call SetTextColor

    ret
PrintWelcome ENDP



;----------Display Date and Time----------
DateTime PROC
    LOCAL originalColor:DWORD

    call GetTextColor
    mov originalColor, eax

    ; Display the message
    mov edx, OFFSET msg1
    call WriteString
    call Crlf

    ; Get the current system time
    INVOKE GetLocalTime, ADDR sysTime

    ; ==== Print YYYY-MM-DD ====
    movzx eax, sysTime.wYear
    call WriteDec
    mov edx, OFFSET dash
    call WriteString

    movzx eax, sysTime.wMonth
    call WriteDec
    mov edx, OFFSET dash
    call WriteString

    movzx eax, sysTime.wDay
    call WriteDec
    mov edx, OFFSET space
    call WriteString

    ; ==== Print HH:MM:SS ====
    movzx eax, sysTime.wHour
    call WriteDec
    mov edx, OFFSET colon
    call WriteString

    movzx eax, sysTime.wMinute
    call WriteDec
    mov edx, OFFSET colon
    call WriteString

    movzx eax, sysTime.wSecond
    call WriteDec
    call Crlf

    ; ==== Greeting Based on Time ====
    movzx eax, sysTime.wHour

    cmp eax, 5
    jl GoodNight           ; 00:00 – 04:59

    cmp eax, 12
    jl GoodMorning         ; 05:00 – 11:59

    cmp eax, 20
    jl GoodAfternoon       ; 12:00 – 19:59

    jmp GoodNight          ; 20:00 – 23:59

GoodMorning:
    mov edx, OFFSET goodMorningMsg
    call WriteString
    jmp EndDateTime

GoodAfternoon:
    mov edx, OFFSET goodAfternoonMsg
    call WriteString
    jmp EndDateTime

GoodNight:
    mov edx, OFFSET goodNightMsg
    call WriteString

EndDateTime:
    mov eax, originalColor  ;restore original text color
    call SetTextColor
    call Crlf
    call Crlf
    ret

DateTime ENDP

ReceiptDateTime PROC
    LOCAL originalColor:DWORD
    
    ; Save original text color
    call GetTextColor
    mov originalColor, eax
    
    ; Get the current system time
    INVOKE GetLocalTime, ADDR sysTime
    
    ; Print date in format YYYY-MM-DD
    movzx eax, sysTime.wYear
    call WriteDec
    
    mov al, '-'
    call WriteChar
    
    ; Ensure month is two digits (add leading zero if needed)
    movzx eax, sysTime.wMonth
    cmp eax, 10
    jae printMonth
    mov al, '0'
    call WriteChar
    
printMonth:
    movzx eax, sysTime.wMonth
    call WriteDec
    
    mov al, '-'
    call WriteChar
    
    ; Ensure day is two digits (add leading zero if needed)
    movzx eax, sysTime.wDay
    cmp eax, 10
    jae printDay
    mov al, '0'
    call WriteChar
    
printDay:
    movzx eax, sysTime.wDay
    call WriteDec
    
    ; Add spacing to align time to the right (adjust as needed)
    mov edx, OFFSET spacingToRight
    call WriteString
    
    ; Print time in format HH:MM:SS
    ; Ensure hour is two digits (add leading zero if needed)
    movzx eax, sysTime.wHour
    cmp eax, 10
    jae printHour
    mov al, '0'
    call WriteChar
    
printHour:
    movzx eax, sysTime.wHour
    call WriteDec
    
    mov al, ':'
    call WriteChar
    
    ; Ensure minute is two digits (add leading zero if needed)
    movzx eax, sysTime.wMinute
    cmp eax, 10
    jae printMinute
    mov al, '0'
    call WriteChar
    
printMinute:
    movzx eax, sysTime.wMinute
    call WriteDec
    
    mov al, ':'
    call WriteChar
    
    ; Ensure second is two digits (add leading zero if needed)
    movzx eax, sysTime.wSecond
    cmp eax, 10
    jae printSecond
    mov al, '0'
    call WriteChar
    
printSecond:
    movzx eax, sysTime.wSecond
    call WriteDec
    
    ; Restore original text color
    mov eax, originalColor
    call SetTextColor
    
    ret
ReceiptDateTime ENDP


;----------Get Credit Card Number----------
GetCardNum PROC
    LOCAL originalColor:DWORD
    ; Store the original text color
    call GetTextColor
    mov originalColor, eax

    ; Prompt for the first card number
    mov edx, OFFSET promptCard1
    call WriteString
    mov eax, lightGreen
    call SetTextColor
    call ReadInt
    mov userCardInput1, eax

    ; Restore the original color after input
    mov eax, originalColor
    call SetTextColor

    ; Prompt for the second card number
    mov edx, OFFSET promptCard2
    call WriteString
    mov eax, lightGreen
    call SetTextColor
    call ReadInt
    mov userCardInput2, eax

    ; Restore the original color after input
    mov eax, originalColor
    call SetTextColor

    ; Validate the first card number
    mov eax, userCardInput1
    cmp eax, validCardInput1
    jne InvalidCard

    ; Validate the second card number
    mov eax, userCardInput2
    cmp eax, validCardInput2
    jne InvalidCard

    ; If both card numbers are valid, show success message
    mov eax, lightGreen
    call SetTextColor
    mov edx, OFFSET validCCMessage
    call WriteString
    call Crlf
    call Crlf

    mov eax, originalColor
    call SetTextColor
    call GetPinNum
    ret
InvalidCard:
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET invalidCCMessage
    call WriteString
    call Crlf
    call Crlf

    ; Restore the original color and retry card input
    mov eax, originalColor
    call SetTextColor
    jmp GetCardNum
GetCardNum ENDP

;----------Get PIN Number----------
GetPinNum PROC
    LOCAL digitCount:DWORD       ; Local variable for digit count
    
    ; Store original text color
    call GetTextColor
    push eax                     ; Save original color on stack
    
    ; Check if the PIN has already been entered and validated
    cmp userPinInput, 0          ; If userPinInput is 0, it hasn't been set
    je PromptForPin              ; Only prompt if no PIN has been entered yet
    
    ; If PIN is already entered, skip prompting
    jmp CheckPin

PromptForPin:
    mov edx, OFFSET promptPin
    call WriteString             ; Show the prompt if it's the first time
    
    ; Initialize userPinInput to 0
    xor eax, eax
    mov userPinInput, eax
    
    ; Initialize digit count
    mov digitCount, 0            ; Start with 0 digits

ReadPinLoop:
    call ReadChar                ; Read a single character
    cmp al, 13                   ; Check if it's Enter key (CR)
    je CheckPin                  ; If Enter, check the PIN
    cmp al, 8                    ; Check if it's Backspace
    je HandleBackspace           ; If Backspace, handle deletion
    
    ; Check if the character is a digit (0-9)
    cmp al, '0'
    jb ReadPinLoop               ; If below '0', ignore
    cmp al, '9'
    ja ReadPinLoop               ; If above '9', ignore
    
    ; Check if we already have 6 digits
    mov ecx, digitCount
    cmp ecx, 6                   ; Check if already at max length
    jae ReadPinLoop              ; If 6+ digits, ignore additional input
    
    ; Echo '*' to the screen in color (mask input)
    push eax                     ; Save the character
    
    ; Set text color to light green (or any color you prefer)
    mov eax, lightGreen          ; Use your desired color constant
    call SetTextColor
    
    mov al, '*'                  ; Load asterisk character
    call WriteChar               ; Display colored asterisk instead of the digit
    pop eax                      ; Restore the character
    
    ; Process the digit
    sub al, '0'                  ; Convert ASCII to numeric value
    movzx ebx, al                ; Zero-extend AL to EBX
    
    ; Multiply current PIN by 10 and add new digit
    mov eax, userPinInput
    mov ecx, 10                  ; Load multiplier
    mul ecx                      ; EDX:EAX = EAX * ECX
    add eax, ebx                 ; Add the new digit
    mov userPinInput, eax        ; Store updated PIN
    
    ; Increment digit count
    inc digitCount               ; Increment our digit counter
    
    jmp ReadPinLoop
    
HandleBackspace:
    ; Check if there's any input to delete
    mov ecx, digitCount
    cmp ecx, 0                   ; If there's no digit entered, do nothing
    je ReadPinLoop
    
    ; Remove the last digit (integer division by 10)
    mov eax, userPinInput
    mov ecx, 10                  ; Divisor for removing last digit
    xor edx, edx                 ; Clear EDX for division
    div ecx                      ; EAX = quotient, EDX = remainder
    mov userPinInput, eax        ; Update PIN with the quotient
    
    ; Erase the last asterisk from screen
    mov al, 8                    ; Backspace character
    call WriteChar
    mov al, ' '                  ; Space character
    call WriteChar
    mov al, 8                    ; Backspace again
    call WriteChar
    
    ; Decrement digit count
    dec digitCount               ; Update our counter
    jmp ReadPinLoop
    
CheckPin:
    ; Restore original text color before continuing
    pop eax                      ; Get original color from stack
    call SetTextColor            ; Restore original color
    
    call Crlf                    ; New line after PIN input
    
    ; Compare entered PIN with valid PIN
    mov eax, userPinInput
    cmp eax, validPinInput
    je isValidPin                ; Jump if PIN is valid
    
    mov eax, lightRed          ; Set text color to red for error message
    call SetTextColor            ; Change text color to red
    mov edx, OFFSET invalidPinMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor

    ; Reset userPinInput so prompt will show again
    xor eax, eax
    mov userPinInput, eax

    jmp GetPinNum                ; Try again
    
isValidPin:
    mov eax, lightGreen          
    call SetTextColor            
    mov edx, OFFSET validPinMessage
    call WriteString
    call Crlf
    call Crlf
    
    ; Store success status or call the next procedure
    mov eax, 1                   ; Set success status code

    mov eax, white
    call SetTextColor            ; Reset text color to white
    call WaitMsg
    
     call DisplayMainMenu          ; Call the main menu procedure
     ret
      
GetPinNum ENDP

;----------Display Main Menu-----------
DisplayMainMenu PROC
   call Clrscr
    
    ; Set text color to green
    mov eax, lightGreen          ; Set the desired color to green
    call SetTextColor            ; Apply the green color
    
    ; Display the message
    mov edx, OFFSET accessGranted  ; Load the address of the message into EDX
    call WriteString             ; Display the message on the screen
    call Crlf                   ; Move to the next line

    mov eax, white
    call SetTextColor

    mov edx, OFFSET mainMenuOptions
    call writeString
    call HandleMainMenu
    ret
DisplayMainMenu ENDP

HandleMainMenu PROC
    ; Display main menu message
    mov eax, white
    call SetTextColor
    mov edx, OFFSET mainMenuMessage
    call WriteString

    mov eax, lightGreen
    call SetTextColor

    ; Read user input
    call ReadInt
    mov mainMenuChoice, eax

    ; Handle valid options
    cmp mainMenuChoice, 1
    je DepositMoney

    cmp mainMenuChoice, 2
    je WithdrawMoney
    
    cmp mainMenuChoice, 3
    je CheckBalance

    cmp mainMenuChoice, 4
    je CurrencyConversion

    cmp mainMenuChoice, 5
    je FutureValueCalculator

    cmp mainMenuChoice, 6
    je Reward

    cmp mainMenuChoice, 7
    je QuitProgram

; Invalid input - display error and return to menu
InvalidInput:
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    jmp HandleMainMenu   ; Loop back to re-display the menu

    ret
HandleMainMenu ENDP


;----------Deposit----------
DepositMoney PROC
    call Clrscr

    mov eax, lightCyan
    call SetTextColor
    mov edx, OFFSET depositTitle
    call WriteString

    mov eax, white
    call SetTextColor
    call Crlf
    call CheckBalance

depositLoop:
    call Crlf
    mov eax, white
    call SetTextColor
    mov edx, OFFSET getDeposit
    call WriteString

    mov eax, lightGreen
    call SetTextColor
    call ReadInt
    mov ecx, 100
    mul ecx                ; EAX = deposit * 100 (in cents)
    mov depositAmount, eax

    cmp eax, 0
    jle invalidDeposit  ; If deposit is <= 0, prompt again

makeConfirmationDeposit:
    mov eax, white
    call SetTextColor
    mov edx, OFFSET confirmDeposit
    call WriteString

    ; Read user input (confirmation)
    mov eax, lightGreen
    call SetTextColor
    call ReadChar
    or al, 32                 ; Convert to lowercase (handles 'Y' and 'y')
    call WriteChar            ; Echo the character

    cmp al, 'y'
    je updateBalance          ; If 'y', proceed to update balance

    call Crlf

    cmp al, 'n'
    je NotConfirmDeposit      ; If 'n', return to deposit loop

    ; Invalid input, re-prompt
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    jmp makeConfirmationDeposit

invalidDeposit:
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET invalidDepositMessage
    call WriteString
    call Crlf
    jmp depositLoop

updateBalance:
    ; === Step 1: Add deposit amount to current balance (both in cents) ===
    mov eax, balance         ; Load current balance (in cents)
    add eax, depositAmount   ; Add deposit amount (in cents)
    mov balance, eax         ; Store the updated balance

    call Crlf
    call Crlf

    ; Convert depositAmount (in cents) to RM for depositTotal calculation
    mov eax, depositAmount     ; Load deposit amount (in cents)
    mov ecx, 100
    xor edx, edx               ; Clear upper part for division
    div ecx                    ; EAX = RM part, EDX = remaining cents

    ; Add RM value to depositTotal
    add depositTotal, eax      ; Update depositTotal (in RM)

    ; === Calculate Reward Points ===
    ; rewardPoints = (depositTotal * rewardRate) / conversionFactor
    mov eax, depositTotal       ; EAX = deposit RM
    mul rewardRate              ; EAX = deposit RM * rewardRate
    div conversionFactor        ; EAX = reward points
    mov rewardPoints, eax       ; Store reward points

    ; === Step 4: Display updated balance message ===
    mov eax, white
    call SetTextColor
    mov edx, OFFSET balanceMessage
    call WriteString
    
    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString

    ; Display current balance (in RM.cents format)
    mov eax, balance           ; Get total balance in cents
    mov ecx, 100
    xor edx, edx
    div ecx                    ; EAX = integer part (RM), EDX = cents

    ; Print integer part (RM)
    call WriteDec              ; Print the RM value

    ; Print decimal point and cents
    mov al, '.'
    call WriteChar
    
    ; Handle cents display properly with leading zero if needed
    mov eax, edx               ; Move cents to EAX for display
    cmp eax, 10
    jge printCents
    mov al, '0'                ; Add leading zero for cents < 10
    call WriteChar

printCents:
    mov eax, edx               ; Ensure cents are in EAX
    call WriteDec

    call Crlf

NotConfirmDeposit:
    ; Continue with next operation
    mov eax, white
    call SetTextColor
    call ContinueRequest

ValidateContinueInput:
    ; Handle 'Y' or 'y'
    mov al, byte ptr [continueOption] ; Load continueOption into AL
    or al, 32                          ; Convert 'Y' to 'y' (if uppercase)
    cmp al, 'y'
    je depositLoop                     ; If 'y' (or 'Y'), go to depositLoop

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je PrintReceiptRequest              ; If 'n' (or 'N'), go to PrintReceiptRequest

    ; Invalid input, prompt again
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage     ; Load invalid input message
    call WriteString                    ; Display invalid input message
    call Crlf
    jmp NotConfirmDeposit               ; Loop back and prompt again

PrintReceiptRequest:    
    call SetTextColor
    call PrintReceiptOption

ValidatePrintReceiptInput:
    ; Handle 'Y' or 'y' for receipt
    mov al, byte ptr [PrintOption] ; Load PrintReceiptOption into AL
    or al, 32
    cmp al, 'y'
    je PrintDepositReceipt
    
    ; Handle 'N' or 'n' for skipping receipt
    mov al, byte ptr [PrintOption] ; Load PrintReceiptOption into AL
    or al, 32
    cmp al, 'n'
    je ChooseAnotherFunction

    ; Invalid input, prompt again
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage     ; Load invalid input message
    call WriteString                    ; Display invalid input message
    call Crlf
    call Crlf
    jmp PrintReceiptRequest               ; Loop back and prompt again

PrintDepositReceipt:
    call ClrScr              ; Clear the screen for a fresh receipt 

    call Crlf
    mov eax, white
    call SetTextColor
    ; Print receipt header
    mov edx, OFFSET receiptHeader
    call WriteString
    call Crlf
    call ReceiptDateTime        ;display date and time

    call Crlf
    call Crlf

    ; Indicate deposit
    mov edx, OFFSET receiptDeposit
    call WriteString

    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString

    ; Display deposit amount in RM
    mov eax, yellow
    call SetTextColor
    mov eax, depositAmount   ; Get deposit amount in cents
    mov ebx, 100
    xor edx, edx
    div ebx                  ; EAX = RM, EDX = cents
    call WriteDec            ; Display RM portion

    ; Display decimal point
    mov al, '.'
    call WriteChar

    ; Ensure two-digit cents display
    cmp edx, 10
    jge printDepositCentsPart
    mov al, '0'
    call WriteChar

printDepositCentsPart:
    mov eax, edx
    call WriteDec

    call Crlf

    ; Print current balance label
    mov eax, white
    call SetTextColor
    mov edx, OFFSET receiptBalance
    call WriteString
    mov eax, yellow
    call SetTextColor
    
    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString

    ; Display current balance (in RM.cents format)
    mov eax, balance
    mov ebx, 100
    xor edx, edx
    div ebx                  ; EAX = RM, EDX = cents

    ; Display RM portion
    mov eax, yellow
    call SetTextColor
    call WriteDec

    ; Display decimal point
    mov al, '.'
    call WriteChar

    ; Ensure two-digit cents display (e.g., 05 instead of 5)
    cmp edx, 10
    jge printDepositCents
    mov al, '0'
    call WriteChar

printDepositCents:
    mov eax, edx
    call WriteDec
    call Crlf
    mov eax, white
    call SetTextColor
    mov edx, OFFSET receiptFooter
    call WriteString
    call Crlf                ; New line after balance
    call Crlf

    mov depositTotal, 0      ; Reset deposit total after printing receipt

ChooseAnotherFunction:
    call RePerformFunction

    ; Handle 'Y' or 'y' to go back to main menu
    mov al, byte ptr [redoOption] ; Load redoOption into AL
    or al, 32
    cmp al, 'y'
    je DisplayMainMenu

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je QuitProgram           ; If 'n' (or 'N'), exit program

ValidateAnotherFuncInput:
   ; Invalid input, prompt again
   mov eax, lightRed
   call SetTextColor
    mov edx, OFFSET errorMessage     ; Load invalid input message
    call WriteString                    ; Display invalid input message
    call Crlf
    call Crlf
    jmp ChooseAnotherFunction               ; Loop back and prompt again

    ret
DepositMoney ENDP

;----------Withdraw----------
WithdrawMoney PROC
    call Clrscr

    mov eax, lightCyan
    call SetTextColor
    mov edx, OFFSET withdrawTitle
    call WriteString

    call Crlf
    mov eax, white
    call SetTextColor

    call CheckBalance


CheckAndWithdraw:
    call Crlf
    mov eax, white
    call SetTextColor
    ; Prompt user for withdrawal amount
    mov edx, OFFSET promptWithdrawalAmount
    call WriteString

    ; Read the withdrawal amount (in RM)
    mov eax, lightGreen
    call SetTextColor
    
    ; Try to read integer input
    call ReadInt
    jno validIntegerInput           ; Jump if no overflow (valid integer)
    
    ; Handle invalid input
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET invalidIntegerMessage  ; ">>> Invalid input. Please enter a valid integer."
    call WriteString
    call Crlf
    jmp CheckAndWithdraw     ; Go back to prompt for withdrawal amount
    
validIntegerInput:
    ; Check if the input is positive
    cmp eax, 0
    jle invalidWithdrawal    ; If <= 0, handle as invalid
    
    ; Store valid withdrawal amount
    mov withdrawalAmount, eax

makeConfirmationWithdrawal:
    mov eax, white
    call SetTextColor
    mov edx, OFFSET confirmWithdraw
    call WriteString

    ; Read user input (confirmation)
    mov eax, lightGreen
    call SetTextColor
    call ReadChar
    or al, 32                 ; Convert to lowercase (handles 'Y' and 'y')
    call WriteChar            ; Echo the character

    cmp al, 'y'
    je UpdateBalance          ; If 'y', proceed to update balance

    call Crlf

    cmp al, 'n'
    je NotConfirmWithdraw     ; If 'n', go to not confirm section

    ; Invalid input, re-prompt
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf                 ; Add blank line after error message
    call Crlf
    jmp makeConfirmationWithdrawal

invalidWithdrawal:
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage  ; ">>> Invalid withdrawal amount. Please enter a positive value."
    call WriteString
    call Crlf
    jmp CheckAndWithdraw

UpdateBalance:
    ; First track the RM amount for bill calculation
    mov eax, withdrawalAmount     ; Load withdrawal amount (in RM)
    add withdrawTotal, eax        ; Add to total withdrawals (in RM)

    ; Convert withdrawal to cents (multiply by 100)
    mov eax, withdrawalAmount
    mov ecx, 100
    mul ecx                       ; EAX = withdrawal * 100 (in cents)
    mov ebx, eax                  ; Save withdrawal in cents in EBX

    ; Check if withdrawal exceeds balance
    cmp ebx, balance
    jg InsufficientFunds          ; If withdrawal > balance, jump to error message

    ; Subtract withdrawal from balance
    mov eax, balance              ; Get current balance
    sub eax, ebx                  ; Subtract withdrawal amount
    mov balance, eax              ; Store new balance

    call Crlf
    call Crlf

    ; Display updated balance
    mov eax, white
    call SetTextColor
    mov edx, OFFSET balanceMessage
    call WriteString

    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString

    ; Display current balance in RM.cents format
    mov eax, balance              ; Get balance in cents
    mov ecx, 100
    xor edx, edx
    div ecx                       ; EAX = integer part (RM), EDX = cents

    ; Print integer part (RM)
    call WriteDec

    ; Print decimal point and cents
    mov al, '.'
    call WriteChar
    
    ; Format cents with leading zero if needed
    mov eax, edx
    cmp eax, 10
    jge printCents
    mov al, '0'
    call WriteChar

printCents:
    mov eax, edx
    call WriteDec
    call Crlf

NotConfirmWithdraw:
    ; Continue with next operation
    mov eax, white
    call SetTextColor
    call ContinueRequest

ValidateContinueInput:
    ; Handle 'Y' or 'y'
    mov al, byte ptr [continueOption] ; Load continueOption into AL
    or al, 32                          ; Convert 'Y' to 'y' (if uppercase)
    cmp al, 'y'
    je CheckAndWithdraw                ; If 'y' (or 'Y'), go to CheckAndWithdraw

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je PrintReceiptRequest             ; If 'n' (or 'N'), go to PrintReceiptRequest

    ; Invalid input, prompt again
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage       ; Load invalid input message
    call WriteString                   ; Display invalid input message
    call Crlf
    jmp NotConfirmWithdraw             ; Loop back and prompt again

PrintReceiptRequest:
    call SetTextColor                  ; Reset text color to white
    call PrintReceiptOption            ; Display the receipt prompt

ValidatePrintReceiptInput:
    ; Handle 'Y' or 'y' for receipt
    mov al, byte ptr [PrintOption]     ; Load PrintReceiptOption into AL
    or al, 32
    cmp al, 'y'
    je PrintWithdrawalReceipt
    
    ; Handle 'N' or 'n' for skipping receipt
    mov al, byte ptr [PrintOption]     ; Load PrintReceiptOption into AL
    or al, 32
    cmp al, 'n'
    je ChooseAnotherFunction

    ; Invalid input, prompt again
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage       ; Load invalid input message
    call WriteString                   ; Display invalid input message
    call Crlf
    call Crlf
    jmp PrintReceiptRequest            ; Loop back and prompt 

PrintWithdrawalReceipt:
    call ClrScr                        ; Clear the screen for a fresh receipt view

    call Crlf
    mov eax, white
    call SetTextColor
    ; Print receipt header
    mov edx, OFFSET receiptHeader
    call WriteString
    call Crlf
    call ReceiptDateTime       
    call Crlf
    call Crlf

    ; Indicate withdrawal
    mov edx, OFFSET receiptWithdraw
    call WriteString

    ; Display withdrawal amount with proper RM formatting
    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    mov eax, withdrawTotal
    call WriteDec

    ; Add .00 for whole RM amounts
    mov al, '.'
    call WriteChar
    mov al, '0'
    call WriteChar
    call WriteChar
    mov eax, white
    call SetTextColor

    call Crlf

    ; Print current balance label
    mov edx, OFFSET receiptBalance
    call WriteString

    ; Display current balance (in RM.cents format)
    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    mov eax, balance
    mov ebx, 100
    xor edx, edx
    div ebx                           ; EAX = RM, EDX = cents

    ; Display RM portion
    call WriteDec

    ; Display decimal point
    mov al, '.'
    call WriteChar

    ; Ensure two-digit cents display (e.g., 05 instead of 5)
    cmp edx, 10
    jge printWithdrawalCents
    mov al, '0'
    call WriteChar

printWithdrawalCents:
    mov eax, edx
    call WriteDec
    call Crlf

    mov eax, white
    call SetTextColor

    ; Start bill breakdown
    mov eax, withdrawTotal

    ; RM100 bills
    mov ebx, 100
    xor edx, edx
    div ebx
    mov bill100, eax
    mov eax, edx

    ; RM50 bills
    mov ebx, 50
    xor edx, edx
    div ebx
    mov bill50, eax
    mov eax, edx

    ; RM20 bills
    mov ebx, 20
    xor edx, edx
    div ebx
    mov bill20, eax
    mov eax, edx

    ; RM10 bills
    mov ebx, 10
    xor edx, edx
    div ebx
    mov bill10, eax
    mov eax, edx

    ; RM5 bills
    mov ebx, 5
    xor edx, edx
    div ebx
    mov bill5, eax
    mov eax, edx

    ; RM1 bills
    mov bill1, eax

    mov edx, OFFSET receiptFooter
    call WriteString
    call Crlf

    ; Output each bill count
    mov edx, OFFSET bill100Msg
    call WriteString
    mov eax, bill100
    call WriteDec
    call Crlf

    mov edx, OFFSET bill50Msg
    call WriteString
    mov eax, bill50
    call WriteDec
    call Crlf

    mov edx, OFFSET bill20Msg
    call WriteString
    mov eax, bill20
    call WriteDec
    call Crlf

    mov edx, OFFSET bill10Msg
    call WriteString
    mov eax, bill10
    call WriteDec
    call Crlf

    mov edx, OFFSET bill5Msg
    call WriteString
    mov eax, bill5
    call WriteDec
    call Crlf

    mov edx, OFFSET bill1Msg
    call WriteString
    mov eax, bill1
    call WriteDec
    call Crlf

    mov edx, OFFSET receiptFooter
    call WriteString
    call Crlf                ; New line after balance

    ; Reset withdrawal total after printing receipt
    mov withdrawTotal, 0
    call Crlf
ChooseAnotherFunction:
    call RePerformFunction

    ; Handle 'Y' or 'y' to go back to main menu
    mov al, byte ptr [redoOption] ; Load redoOption into AL
    or al, 32
    cmp al, 'y'
    je DisplayMainMenu

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je QuitProgram              ; If 'n' (or 'N'), go to QuitProgram

ValidateAnotherFuncInput:
    ; Invalid input, prompt again
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage     ; Load invalid input message
    call WriteString                 ; Display invalid input message
    call Crlf
    call Crlf
    jmp ChooseAnotherFunction        ; Loop back and prompt again

InsufficientFunds:
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET notSufficientBalance
    call WriteString
    call Crlf
    call Crlf
    jmp CheckAndWithdraw

    ret
WithdrawMoney ENDP

;----------Check Balance----------
CheckBalance PROC
    ; Set initial color
    mov eax, white
    call SetTextColor
    
    ; Check if we're coming from the main menu option 3
    mov eax, mainMenuChoice
    cmp eax, 3
    jne SkipCheckBalanceHeader   ; Skip header if not from main menu
    
    ; Display header for check balance screen
    call ClrScr
    mov eax, lightCyan
    call SetTextColor
    mov edx, OFFSET checkBalanceTitle
    call WriteString
    call Crlf
    mov eax, white
    call SetTextColor
    call Crlf
    
SkipCheckBalanceHeader:
    ; Display balance message
    mov edx, OFFSET balanceMessage
    call WriteString
    
    ; Display the balance with currency symbol
    mov eax, yellow    
    call SetTextColor
    mov edx, OFFSET balanceUnit     ; RM Unit
    call WriteString
    
    ; Calculate and display the balance in RM.xx format
    mov eax, balance
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx            ; EAX = balance / 100, EDX = balance % 100
    call WriteDec      ; Print whole number (RM part)
    
    ; Print decimal point
    mov al, '.'
    call WriteChar
    
    ; Print the decimal part (EDX contains cents)
    mov eax, edx
    cmp eax, 10        ; Ensure two-digit display (e.g., 05 instead of 5)
    jae printCents     ; Changed from jg to jae for proper comparison
    mov al, '0'        ; Print leading zero for values < 10
    call WriteChar
    
printCents:
    mov eax, edx
    call WriteDec      ; Print cents
    call Crlf
    
    ; Determine if we need to request reperform
    cmp mainMenuChoice, 3
    je RequestReperform
    jmp ExitCheckBalance    ; Added direct jump to exit to simplify flow
    
RequestReperform:
    call Crlf
    call RePerformFunction
    
    ; Handle user response
    mov al, byte ptr [redoOption] ; Load redoOption into AL
    or al, 32                    ; Convert to lowercase
    
    cmp al, 'y'
    je DisplayMainMenu
    
    cmp al, 'n'
    je QuitProgram
    
    ; If invalid input (neither 'y' nor 'n'), handle it
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorInvalidOption    ; You need to define this string
    call WriteString
    call Crlf
    mov eax, white
    call SetTextColor
    jmp RequestReperform    ; Ask again
    
ExitCheckBalance:
    ret
CheckBalance ENDP
;----------Currency Conversion----------
CurrencyConversion PROC
CurrencyConversionLoop:
    call Clrscr
    call CurrencyMenu
    call HandleChosenCurrency
    call Crlf

NotConfirmWithdraw:
    mov eax, white           ; Set prompt text to white
    call SetTextColor
    call ContinueRequest

ValidateContinueInput:
    ; Handle 'Y' or 'y'
    mov al, byte ptr [continueOption] ; Load continueOption into AL
    or al, 32                          ; Convert 'Y' to 'y' (if uppercase)
    cmp al, 'y'
    je CurrencyConversionLoop          ; If 'y' (or 'Y'), go to CheckAndWithdraw

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je PrintReceiptRequest              ; If 'n' (or 'N'), go to PrintReceiptRequest

    ; Invalid input, prompt again
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage     ; Load invalid input message
    call WriteString                  ; Display invalid input message
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp NotConfirmWithdraw               ; Loop back and prompt again

PrintReceiptRequest:
    mov eax, white           ; Set prompt text to white
    call SetTextColor
    call PrintReceiptOption    ; Display the receipt prompt

    ; Handle 'Y' or 'y' for receipt
    mov al, byte ptr [PrintOption] ; Load PrintReceiptOption into AL
    or al, 32
    cmp al, 'y'
    je PrintWithdrawalReceipt
    
    ; Handle 'N' or 'n' for skipping receipt
    mov al, byte ptr [PrintOption] ; Load PrintReceiptOption into AL
    or al, 32
    cmp al, 'n'
    je ChooseAnotherFunction

    ; Invalid input, prompt again
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage     ; Load invalid input message
    call WriteString                    ; Display invalid input message
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp PrintReceiptRequest               ; Loop back and prompt 

PrintWithdrawalReceipt:
    call ClrScr              ; Clear the screen for a fresh receipt view

    ; Print receipt header - WHITE
    mov eax, white           ; Set receipt headers to white
    call SetTextColor
    mov edx, OFFSET receiptHeader
    call WriteString
    call Crlf
    
    call ReceiptDateTime        ; Display date and time
    call Crlf
    call Crlf

    ; Indicate withdrawal - WHITE
    mov edx, OFFSET receiptWithdraw
    call WriteString

    ; Display withdrawal amount - YELLOW
    mov eax, yellow          ; Set result to yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    mov eax, WithdrawTotal
    call WriteDec
    call Crlf

    ; Print current balance label - WHITE
    mov eax, white           ; Reset to white for labels
    call SetTextColor
    mov edx, OFFSET receiptBalance
    call WriteString

    ; Display current balance in yellow (in RM.cents format) - YELLOW
    mov eax, yellow          ; Set result to yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    
    ; Display RM amount with decimal point
    mov eax, balance
    mov ebx, 100
    xor edx, edx
    div ebx                  ; EAX = RM, EDX = cents
    call WriteDec            ; Display RM portion
    
    ; Display decimal point
    mov al, '.'
    call WriteChar

    ; Ensure two-digit cents display (e.g., 05 instead of 5)
    cmp edx, 10
    jge printWithdrawalCents
    mov al, '0'
    call WriteChar

printWithdrawalCents:
    mov eax, edx
    call WriteDec
    call Crlf  

    mov withdrawTotal, 0

USDTotal:
    ; Label - WHITE
    mov eax, white           
    call SetTextColor
    mov edx, OFFSET message7
    call WriteString

    ; Value - YELLOW
    mov eax, yellow          
    call SetTextColor
    mov edx, OFFSET USDUnit
    call WriteString
    mov eax, totalAmountUSD
    call WriteDec
    call Crlf

EURTotal:
    ; Label - WHITE
    mov eax, white           
    call SetTextColor
    mov edx, OFFSET message7
    call WriteString

    ; Value - YELLOW
    mov eax, yellow          
    call SetTextColor
    mov edx, OFFSET EURUnit
    call WriteString
    mov eax, totalAmountEUR
    call WriteDec
    call Crlf

GBPTotal:
    ; Label - WHITE
    mov eax, white           
    call SetTextColor
    mov edx, OFFSET message7
    call WriteString

    ; Value - YELLOW
    mov eax, yellow          
    call SetTextColor
    mov edx, OFFSET GBPUnit
    call WriteString
    mov eax, totalAmountGBP
    call WriteDec
    call Crlf

JPYTotal:
    ; Label - WHITE
    mov eax, white           
    call SetTextColor
    mov edx, OFFSET message7
    call WriteString

    ; Value - YELLOW
    mov eax, yellow          
    call SetTextColor
    mov edx, OFFSET JPYUnit
    call WriteString
    mov eax, totalAmountJPY
    call WriteDec
    call Crlf

AUDTotal:
    ; Label - WHITE
    mov eax, white           
    call SetTextColor
    mov edx, OFFSET message7
    call WriteString

    ; Value - YELLOW
    mov eax, yellow          
    call SetTextColor
    mov edx, OFFSET AUDUnit
    call WriteString
    mov eax, totalAmountAUD
    call WriteDec
    call Crlf

    ; Footer - WHITE
    mov eax, white           
    call SetTextColor
    mov edx, OFFSET receiptFooter
    call WriteString
    call Crlf             
    call Crlf

ChooseAnotherFunction:
    mov eax, white           ; Set prompt text to white
    call SetTextColor
    call RePerformFunction

    ; Handle 'Y' or 'y' to go back to main menu
    mov al, byte ptr [redoOption] ; Load redoOption into AL
    or al, 32
    cmp al, 'y'
    je DisplayMainMenu

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je QuitProgram              ; If 'n' (or 'N'), go to PrintReceiptRequest

    ret
CurrencyConversion ENDP

CurrencyMenu PROC
    mov eax, lightCyan
    call SetTextColor
    ; Display currency title
    mov edx, OFFSET currencyTitle
    call WriteString
    call Crlf

    ; Display currency menu
    mov eax, white
    call SetTextColor
    mov edx, OFFSET currencyMenuText
    call WriteString

    ; Display prompt
    mov edx, OFFSET promptCurrency
    call WriteString

    ; Read user input
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    call ReadInt
    mov chosenCurrency, eax

    ret
CurrencyMenu ENDP

;---------- Handle Chosen Currency ----------
HandleChosenCurrency PROC
    ; Read chosen currency again from stored variable
    mov eax, chosenCurrency

    ; Validate input range (1-6)
    cmp eax, 1
    jl InvalidInput
    cmp eax, 6
    jg InvalidInput

    cmp eax, 1
    je USDConventor

    cmp eax, 2
    je EURConventor

    cmp eax, 3
    je GBPConventor

    cmp eax, 4
    je JPYConventor

    cmp eax, 5
    je AUDConventor

    cmp eax, 6
    je DisplayMainMenu 

    jmp Done  ; Add this to handle fall-through case (although it shouldn't happen)

; Invalid input - display error and return to menu
InvalidInput:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    
    ; Instead of jumping to CurrencyMenu, we'll call it and then
    ; recursively call HandleChosenCurrency to re-validate the new input
    call WaitMsg
    call ClrScr
    call CurrencyMenu
    call HandleChosenCurrency  ; Recursive call to validate new input
    
Done:
    ret
HandleChosenCurrency ENDP

;---------- Currency Conventor ----------
USDConventor PROC
getConversionAmount:
    mov eax, white          ; Set prompt text to white
    call SetTextColor
    MOV EDX, OFFSET Message1
    Call WriteString
    
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    Call ReadDec
    MOV withdrawalamount, eax

    ; Input validation - must be positive
    cmp eax, 0
    jle invalidWithdrawal    ; Changed from jl to jle to also catch zero

    ; Validate if there's enough balance
    mov eax, withdrawalamount
    mov ebx, rateUSD
    mul ebx                  ; Calculate amount needed in local currency
    
    ; Check if we have enough balance
    cmp eax, balance
    jg insufficientFunds

makeConfirmationWithdrawal:

    mov eax, white          ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET confirmWithdraw
    call WriteString

    ; Read user input (confirmation)
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    call ReadChar
    or al, 32                 ; Convert to lowercase (handles 'Y' and 'y')
    call WriteChar            ; Echo the character

    cmp al, 'y'
    je convertUSD          ; If 'y', proceed to update balance

    call Crlf

    cmp al, 'n'
    je getConversionAmount            ; If 'n', return to deposit loop

    ; Invalid input, re-prompt
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp makeConfirmationWithdrawal

invalidWithdrawal:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp getConversionAmount

insufficientFunds:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET insufficientFundsMessage    ; Need to define this message in data section
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp getConversionAmount

convertUSD:
    MOV eax, withdrawalamount 
    MOV ebx, rateUSD
    MUL ebx
    MOV Amount, EAX
    MOV EAX, amount
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    mul ebx

    mov amount, eax
    mov eax, balance

    SUB EAX, Amount
    MOV balance, EAX

    mov eax, amount
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx
    mov amount, eax

    mov eax, withdrawTotal
    add eax, amount
    mov withdrawTotal, eax

    mov eax, totalAmountUSD
    add eax, withdrawalamount    ; FIXED: changed from withdrawalAmount
    mov totalAmountUSD, eax

Print:
    call Crlf
    call Crlf
    
    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message6
    CALL WriteString
    
    ; Value - YELLOW
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    MOV EAX, Amount 
    CALL WriteDec
    CAll Crlf

    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message7 
    Call Writestring
    
    ; Value - YELLOW
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET USDUnit
    call WriteString
    MOV EAX, withdrawalamount 
    Call WriteDec
    CAll Crlf

    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message8
    Call WriteString 
    
    ; Value - YELLOW (including RM and cents)
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    MOV EAX, balance
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx
    Call WriteDec

    ; Print decimal point (still YELLOW)
    mov al, '.'
    call WriteChar

    ; Print the decimal part in YELLOW
    mov eax, edx
    cmp eax, 10         ; Ensure two-digit display (e.g., 05 instead of 5)
    jge printCents
    mov al, '0'        ; Print leading zero for values < 10
    call WriteChar

printCents:
    mov eax, edx
    call WriteDec      ; Print cents

    ret
USDConventor ENDP

EURConventor PROC
getEURConversionAmount:
    mov eax, white          ; Set prompt text to white
    call SetTextColor
    MOV EDX, OFFSET Message2
    Call WriteString
    
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    Call ReadDec
    MOV withdrawalamount, eax

    ; Input validation - must be positive
    cmp eax, 0
    jle invalidEURWithdrawal

    ; Validate if there's enough balance
    mov eax, withdrawalamount
    mov ebx, rateEUR
    mul ebx                  ; Calculate amount needed in local currency
    
    ; Check if we have enough balance
    cmp eax, balance
    jg insufficientEURFunds

makeEURConfirmation:

    mov eax, white          ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET confirmWithdraw
    call WriteString

    ; Read user input (confirmation)
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    call ReadChar
    or al, 32               ; Convert to lowercase (handles 'Y' and 'y')
    call WriteChar          ; Echo the character

    cmp al, 'y'
    je convertEUR           ; If 'y', proceed to update balance

    call Crlf

    cmp al, 'n'
    je getEURConversionAmount  ; If 'n', return to deposit loop

    ; Invalid input, re-prompt
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp makeEURConfirmation

invalidEURWithdrawal:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp getEURConversionAmount

insufficientEURFunds:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET insufficientFundsMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp getEURConversionAmount

convertEUR:
    MOV eax, withdrawalamount 
    Mov ebx, rateEUR
    MUL ebx
    mov Amount, EAX
    MOV EAX, amount
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    mul ebx

    mov amount, eax
    mov eax, balance

    SUB EAX, Amount
    MOV balance, EAX

    mov eax, amount
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx
    mov amount, eax

    mov eax, withdrawTotal
    add eax, amount
    mov withdrawTotal, eax

    mov eax, totalAmountEUR
    add eax, withdrawalamount    ; FIXED: changed from withdrawalAmount
    mov totalAmountEUR, eax

PrintEUR:
    call Crlf
    call Crlf
    
    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message6
    CALL WriteString 
    
    ; Value - YELLOW
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    MOV EAX, Amount 
    CALL WriteDec
    CAll Crlf

    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message7
    Call Writestring
    
    ; Value - YELLOW
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET EURUnit
    call WriteString
    MOV EAX, withdrawalamount 
    Call WriteDec
    CAll Crlf

    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message8
    Call WriteString 
    
    ; Value - YELLOW (including RM and cents)
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    MOV EAX, balance
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx
    Call WriteDec

    ; Print decimal point (still YELLOW)
    mov al, '.'
    call WriteChar

    ; Print the decimal part in YELLOW
    mov eax, edx
    cmp eax, 10         ; Ensure two-digit display (e.g., 05 instead of 5)
    jge printEURCents
    mov al, '0'        ; Print leading zero for values < 10
    call WriteChar

printEURCents:
    mov eax, edx
    call WriteDec      ; Print cents

    ret
EURConventor ENDP

GBPConventor PROC
getGBPConversionAmount:
    mov eax, white          ; Set prompt text to white
    call SetTextColor
    MOV EDX, OFFSET Message3
    Call WriteString
    
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    Call ReadDec
    MOV withdrawalamount, eax

    ; Input validation - must be positive
    cmp eax, 0
    jle invalidGBPWithdrawal

    ; Validate if there's enough balance
    mov eax, withdrawalamount
    mov ebx, rateGBP
    mul ebx                  ; Calculate amount needed in local currency
    
    ; Check if we have enough balance
    cmp eax, balance
    jg insufficientGBPFunds

makeGBPConfirmation:

    mov eax, white          ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET confirmWithdraw
    call WriteString

    ; Read user input (confirmation)
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    call ReadChar
    or al, 32               ; Convert to lowercase (handles 'Y' and 'y')
    call WriteChar          ; Echo the character

    cmp al, 'y'
    je convertGBP           ; If 'y', proceed to update balance

    call Crlf

    cmp al, 'n'
    je getGBPConversionAmount  ; If 'n', return to deposit loop

    ; Invalid input, re-prompt
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp makeGBPConfirmation

invalidGBPWithdrawal:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp getGBPConversionAmount

insufficientGBPFunds:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET insufficientFundsMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp getGBPConversionAmount

convertGBP:
    MOV eax, withdrawalamount 
    Mov ebx, rateGBP
    MUL ebx
    mov Amount, EAX
    MOV EAX, amount
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    mul ebx

    mov amount, eax
    mov eax, balance

    SUB EAX, Amount
    MOV balance, EAX

    mov eax, amount
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx
    mov amount, eax

    mov eax, withdrawTotal
    add eax, amount
    mov withdrawTotal, eax

    mov eax, totalAmountGBP
    add eax, withdrawalamount    ; FIXED: changed from withdrawalAmount
    mov totalAmountGBP, eax

PrintGBP:
    call Crlf
    call Crlf
    
    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message6
    CALL WriteString 
    
    ; Value - YELLOW
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    MOV EAX, Amount 
    CALL WriteDec
    CAll Crlf

    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message7 
    Call Writestring
    
    ; Value - YELLOW
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET GBPUnit
    call WriteString
    MOV EAX, withdrawalamount 
    Call WriteDec
    CAll Crlf

    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message8
    Call WriteString 
    
    ; Value - YELLOW (including RM and cents)
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    MOV EAX, balance
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx
    Call WriteDec

    ; Print decimal point (still YELLOW)
    mov al, '.'
    call WriteChar

    ; Print the decimal part in YELLOW
    mov eax, edx
    cmp eax, 10         ; Ensure two-digit display (e.g., 05 instead of 5)
    jge printGBPCents
    mov al, '0'        ; Print leading zero for values < 10
    call WriteChar

printGBPCents:
    mov eax, edx
    call WriteDec      ; Print cents

    ret
GBPConventor ENDP

JPYConventor PROC
getJPYConversionAmount:
    mov eax, white          ; Set prompt text to white
    call SetTextColor
    MOV EDX, OFFSET Message4
    Call WriteString
    
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    Call ReadDec
    MOV withdrawalamount, eax

    ; Input validation - must be positive
    cmp eax, 0
    jle invalidJPYWithdrawal

    ; Validate if there's enough balance
    mov eax, withdrawalamount
    mov ebx, rateJPY
    mul ebx                  ; Calculate amount needed in local currency
    
    ; Check if we have enough balance
    cmp eax, balance
    jg insufficientJPYFunds

makeJPYConfirmation:

    mov eax, white          ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET confirmWithdraw
    call WriteString

    ; Read user input (confirmation)
    mov eax, lightGreen     ; Set input color to light green
    call SetTextColor
    call ReadChar
    or al, 32               ; Convert to lowercase (handles 'Y' and 'y')
    call WriteChar          ; Echo the character

    cmp al, 'y'
    je convertJPY           ; If 'y', proceed to update balance

    call Crlf

    cmp al, 'n'
    je getJPYConversionAmount  ; If 'n', return to deposit loop

    ; Invalid input, re-prompt
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp makeJPYConfirmation

invalidJPYWithdrawal:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp getJPYConversionAmount

insufficientJPYFunds:
    mov eax, lightRed            ; Set error message to red
    call SetTextColor
    mov edx, OFFSET insufficientFundsMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white          ; Reset to white
    call SetTextColor
    jmp getJPYConversionAmount

convertJPY:
    MOV eax, withdrawalamount 
    Mov ebx, rateJPY
    MUL ebx
    mov Amount, EAX
    MOV EAX, amount
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    mul ebx

    mov amount, eax
    mov eax, balance

    SUB EAX, Amount
    MOV balance, EAX

    mov eax, amount
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx
    mov amount, eax

    mov eax, withdrawTotal
    add eax, amount
    mov withdrawTotal, eax

    mov eax, totalAmountJPY
    add eax, withdrawalamount    ; FIXED: changed from withdrawalAmount
    mov totalAmountJPY, eax

PrintJPY:
    call Crlf
    call Crlf
    
    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message6
    CALL WriteString 
    
    ; Value - YELLOW
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    MOV EAX, Amount 
    CALL WriteDec
    CAll Crlf

    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message7 
    Call Writestring
    
    ; Value - YELLOW
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET JPYUnit
    call WriteString
    MOV EAX, withdrawalamount 
    Call WriteDec
    CAll Crlf

    ; Label - WHITE
    mov eax, white          
    call SetTextColor
    MOV EDX, OFFSET Message8
    Call WriteString 
    
    ; Value - YELLOW (including RM and cents)
    mov eax, yellow         
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    MOV EAX, balance
    mov ebx, 100
    xor edx, edx       ; Clear edx for division
    div ebx
    Call WriteDec

    ; Print decimal point (still YELLOW)
    mov al, '.'
    call WriteChar

    ; Print the decimal part in YELLOW
    mov eax, edx
    cmp eax, 10         ; Ensure two-digit display (e.g., 05 instead of 5)
    jge printJPYCents
    mov al, '0'        ; Print leading zero for values < 10
    call WriteChar

printJPYCents:
    mov eax, edx
    call WriteDec      ; Print cents

    ret 
JPYConventor ENDP

AUDConventor PROC
getAUDConversionAmount:
    mov eax, white
    call SetTextColor
    mov edx, OFFSET Message5
    call WriteString

    mov eax, lightGreen
    call SetTextColor
    call ReadDec
    mov withdrawalamount, eax

    cmp eax, 0
    jle invalidAUDWithdrawal

    mov eax, withdrawalamount
    mov ebx, rateAUD
    mul ebx

    cmp eax, balance
    jg insufficientAUDFunds

makeAUDConfirmation:
    mov eax, white
    call SetTextColor
    mov edx, OFFSET confirmWithdraw
    call WriteString

    mov eax, lightGreen
    call SetTextColor
    call ReadChar
    or al, 32
    call WriteChar

    cmp al, 'y'
    je convertAUD

    call Crlf
    cmp al, 'n'
    je getAUDConversionAmount

    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    jmp makeAUDConfirmation

invalidAUDWithdrawal:
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    jmp getAUDConversionAmount

insufficientAUDFunds:
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET insufficientFundsMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    jmp getAUDConversionAmount

convertAUD:
    mov eax, withdrawalamount 
    mov ebx, rateAUD
    mul ebx
    mov Amount, eax

    mov eax, amount
    mov ebx, 100
    xor edx, edx
    mul ebx
    mov amount, eax

    mov eax, balance
    sub eax, Amount
    mov balance, eax

    mov eax, amount
    mov ebx, 100
    xor edx, edx
    div ebx
    mov amount, eax

    mov eax, withdrawTotal
    add eax, amount
    mov withdrawTotal, eax

    mov eax, totalAmountAUD
    add eax, withdrawalamount
    mov totalAmountAUD, eax

PrintAUD:
    call Crlf
    call Crlf

    mov eax, white
    call SetTextColor
    mov edx, OFFSET Message6
    call WriteString

    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    mov eax, Amount
    call WriteDec
    call Crlf

    mov eax, white
    call SetTextColor
    mov edx, OFFSET Message7
    call WriteString

    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET AUDUnit
    call WriteString
    mov eax, withdrawalamount
    call WriteDec
    call Crlf

    mov eax, white
    call SetTextColor
    mov edx, OFFSET Message8
    call WriteString

    mov eax, yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    mov eax, balance
    mov ebx, 100
    xor edx, edx
    div ebx
    call WriteDec

    mov al, '.'
    call WriteChar

    mov eax, edx
    cmp eax, 10
    jge printAUDCents
    mov al, '0'
    call WriteChar

printAUDCents:
    mov eax, edx
    call WriteDec

    ret
AUDConventor ENDP

;----------Future Value Calculation----------
FutureValueCalculator PROC
    call ClrScr

    ; === Get Deposit Amount (in RM) with validation ===

get_deposit:

    mov edx, OFFSET futureValueCalTitle
    mov eax, lightCyan  
    call SetTextColor
    call WriteString
    call Crlf
    call Crlf

    mov eax, white    
    call SetTextColor
    mov edx, OFFSET promptDeposit
    call WriteString
    
    mov eax, lightGreen  
    call SetTextColor
    call ReadInt      ; Integer because deposit money is only
    
    ; Validate deposit (must be > 0)
    cmp eax, 0
    jg valid_deposit
    
    ; Invalid deposit - Show error and reprompt
    mov eax, lightRed      
    call SetTextColor
    mov edx, OFFSET errorNegative
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    call WaitMsg
    call ClrScr
    jmp get_deposit   ; Reprompt for deposit
    
valid_deposit:
    mov deposit, eax  ; Store valid deposit (in RM)
    
    ; === Get Interest Rate (as a whole number percentage) with validation ===
get_rate:
    mov eax, white    
    call SetTextColor
    mov edx, OFFSET promptRate
    call WriteString
    
    mov eax, lightGreen  
    call SetTextColor
    call ReadInt
    
    ; Validate interest rate (must be > 0)
    cmp eax, 0
    jg valid_rate
    
    ; Invalid interest rate - Show error and reprompt
    mov eax, lightRed     
    call SetTextColor
    mov edx, OFFSET errorNegative
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    jmp get_rate      ; Reprompt for interest rate
    
valid_rate:
    mov interestRate, eax  ; Store valid interest rate
    
    ; === Get Number of Years with validation ===
get_years:
    mov eax, white    
    call SetTextColor
    mov edx, OFFSET promptYears
    call WriteString
    
    mov eax, lightGreen  
    call SetTextColor
    call ReadInt
    
    ; Validate years (must be > 0)
    cmp eax, 0
    jg valid_years
    
    ; Invalid years - Show error and reprompt
    mov eax, lightRed      
    call SetTextColor
    mov edx, OFFSET errorNegative
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    jmp get_years     ; Reprompt for years
    
valid_years:
    mov years, eax    ; Store valid number of years
    
    ; Reset text color for calculations
    mov eax, white
    call SetTextColor

    ; Convert deposit to sen (1 RM = 100 sen)
    mov eax, deposit
    imul eax, oneHundred    ; Convert deposit to sen --> Signed Multiplication (Avoid Overflow)
    mov deposit, eax        ; Store the deposit in sen
    
    ; Initialize Future Value in sen (starting with 0)
    mov futureValue, 0
    
    ; Loop to compute FV using corrected compound interest formula
    mov ecx, years    ; Set the loop counter to the number of years

first_year:
    ; First Year - Only add deposit (No Interest Applied)
    mov eax, deposit
    add futureValue, eax
    loop after_first_year  ; Skip interest calculation for the first year --> The loop instruction decrements ecx by 1.

after_first_year: ; No interest calculation at here

calc_loop:
    cmp ecx, 0
    je display_result           ; Exit loop if years == 0
    ; Step 1: Apply interest BEFORE adding deposit
    mov eax, futureValue
    mov edx, 0            
    imul eax, interestRate      ; Multiply FV by interestRate
    mov edx, 0               
    idiv oneHundred             ; Divide by 100 for proper scaling --> Signed Division (Avoid Overflow)

    ; Step 2: Add computed interest to FV
    add futureValue, eax

    ; Step 3: Add deposit (new yearly deposit in sen)
    mov eax, deposit
    add futureValue, eax
    ; Check for overflow before continuing
    jnc continueLoop    ;jump if no carry
    
    mov eax, lightRed       
    call SetTextColor
    mov edx, OFFSET overflowMessage
    call WriteString
    mov eax, white      
    call SetTextColor
    jmp QuitProgram
    
continueLoop:
    loop calc_loop    ; Decrement the year counter and repeat the loop
    
display_result:
    ; --- Display Future Value in RM and Sen ---
    mov eax, white    
    call SetTextColor
    mov edx, OFFSET resultMsg
    call WriteString
    
    mov eax, yellow   
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call WriteString
    ; Convert future value from sen to RM and sen
    mov eax, futureValue
    mov edx, 0
    div oneHundred    ; EAX = RM, EDX = sen

    ; Display RM part
    call WriteDec
    mov al, '.'    ; Print decimal point
    call WriteChar

    ; Display Sen part (ensure two digits)
    mov eax, edx            ; Move sen to EAX (remainder store in edx)
    cmp eax, 10             ; If less than 10, add leading zero) (5sen become .05)
    jae print_sen           ;(>= 10, proceed to print_sen)
    mov al, '0'             ; add trailing zero
    call WriteChar

print_sen:
    call WriteDec
    
    mov eax, white    ; Reset to white for continue prompts
    call SetTextColor
    call Crlf
    jmp ValidateContinueOption
    
ValidateContinueOption:
    mov eax, white
    call SetTextColor
    call ContinueRequest                    

    mov al, byte ptr [continueOption]
    or al, 32                               
    cmp al, 'y'
    je FutureValueCalculator

    cmp al, 'n'
    je ChooseAnotherFunction

    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorInvalidOption
    call WriteString
    call Crlf
    mov eax, white
    call SetTextColor
    jmp ValidateContinueOption

ChooseAnotherFunction:

    call RePerformFunction

    ; Handle 'Y' or 'y' to go back to main menu
    mov al, byte ptr [redoOption] ; Load redoOption into AL
    or al, 32
    cmp al, 'y'
    je DisplayMainMenu

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je QuitProgram                         ; If 'n' (or 'N'), exit program

    ; Invalid input, prompt again
    mov eax, lightRed
    call SetTextColor
    mov edx, OFFSET errorInvalidOption      ; Load invalid input message
    call WriteString                        ; Display invalid input message
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    jmp ChooseAnotherFunction               ; Loop back and prompt again

ReturnMainMenu:
    mov eax, white        ; Reset text color
    call SetTextColor
    ret                   ; Return to main menu

FutureValueCalculator ENDP

;----------Reward Points----------
Reward PROC
    call ClrScr

RewardMenuLoop:
    mov eax, lightCyan
    call SetTextColor
    mov edx, OFFSET rewardTitle
    call writeString

    call Crlf
    mov eax, white
    call SetTextColor
    mov edx, OFFSET rewardPointsMessage
    call writeString
    
    mov eax, yellow
    call SetTextColor
    mov eax, rewardPoints
    call writeDec

    mov edx, OFFSET points
    call writeString

    call Crlf
    call Crlf

    mov eax, white
    call SetTextColor
    mov edx, OFFSET rewardMenu
    call writeString

    mov edx, OFFSET rewardMenuMsg
    call writeString
    mov eax, lightGreen
    call SetTextColor
    call readInt

    mov rewardMenuChoice, eax

    ; Validate input range (1-4)
    cmp eax, 1
    jl InvalidInput
    cmp eax, 4
    jg InvalidInput

    cmp rewardMenuChoice, 1
    je RedeemPoints

    cmp rewardMenuChoice, 2
    je EstimateFutureRewards

    cmp rewardMenuChoice, 3
    je DisplayMainMenu

    cmp rewardMenuChoice, 4
    je QuitProgram

    jmp RequestReperform  ; Add fallthrough protection

InvalidInput:
    mov eax, lightRed            ; Set error message to red (changed from lightRed)
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf               ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    call WaitMsg
    call ClrScr
    jmp RewardMenuLoop      ; Loop back to re-display the menu

RequestReperform:
    call RePerformFunction

    ; Handle 'Y' or 'y' to go back to main menu
    mov al, byte ptr [redoOption] ; Load redoOption into AL
    or al, 32
    cmp al, 'y'
    je DisplayMainMenu

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je DisplayMainMenu              

    ; Invalid input for redoOption
    mov eax, lightRed               
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf                  
    mov eax, white
    call SetTextColor
    jmp RequestReperform       ; Loop back for valid input

    ret
Reward ENDP

RedeemPoints PROC
    call ClrScr
RedeemMenuLoop:
    mov eax, white
    call SetTextColor
    mov edx, OFFSET redeemPointsMenu
    call writeString

    mov edx, OFFSET redeemPointsMsg
    call writeString

    mov eax, lightGreen
    call SetTextColor
    call ReadInt
    mov redeemPointChoice, eax

    ; Validate input range (1-4)
    cmp eax, 1
    jl InvalidRedeemPointChoice
    cmp eax, 4
    jg InvalidRedeemPointChoice

    cmp redeemPointChoice, 1 
    je pointToMoney

    cmp redeemPointChoice, 2
    je redeemVoucherCode

    cmp redeemPointChoice, 3
    je Reward

    cmp redeemPointChoice, 4
    je QuitProgram

InvalidRedeemPointChoice:
    mov eax, lightRed                ; Set error message to red (changed from lightRed)
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf                   ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    call WaitMsg
    call ClrScr
    jmp RedeemMenuLoop          ; Loop back to re-display the menu

pointToMoney:
    call Crlf

getRedeemPointsLoop:
    mov eax, white              ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET pointToMoneyMsg
    call writeString

    mov eax, lightGreen
    call SetTextColor
    call ReadInt
    mov pointToMoneyAmount, eax

    ; Input validation - must be positive
    cmp eax, 0
    jle invalidPointAmountInput

    mov eax, rewardPoints
    cmp pointToMoneyAmount, eax
    jbe makeConfirmationRedeemMoney

    mov eax, lightRed                ; Set error message to red (changed from lightRed)
    call SetTextColor
    mov edx, OFFSET insufficientRewardPoint
    call writeString
    call Crlf
    call Crlf                   ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    jmp getRedeemPointsLoop

invalidPointAmountInput:
    mov eax, lightRed                ; Set error message to red
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage  ; Reuse this error message
    call writeString
    call Crlf
    call Crlf                   ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    call WaitMsg
    call ClrScr
    jmp RedeemMenuLoop

makeConfirmationRedeemMoney:
    mov eax, white              ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET confirmRedeemMoney
    call WriteString

    ; Read user input (confirmation)
    mov eax, lightGreen
    call SetTextColor
    call ReadChar
    or al, 32                   ; Convert to lowercase (handles 'Y' and 'y')
    call WriteChar              ; Echo the character

    cmp al, 'y'
    je DeductRewardPoints       ; If 'y', proceed to update balance

    call Crlf

    cmp al, 'n'
    je NotConfirmRedeemMoney    ; If 'n', return to deposit loop

    ; Invalid input, re-prompt
    mov eax, lightRed                ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf                   ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    jmp makeConfirmationRedeemMoney

DeductRewardPoints:
    mov eax, pointToMoneyAmount
    mov ecx, 10
    xor edx, edx
    div ecx                ; EAX = pointToCash / 10, EDX = pointToCash % 10
    mov moneyRedeemAmount, eax
    mov leftoverPoints, edx 
    mov ecx, 100
    mul ecx
    add balance, eax

    mov eax, rewardPoints
    add eax, leftoverPoints
    mov rewardPoints, eax

    mov eax, rewardPoints
    add eax, edx
    mov rewardPoints, eax

    mov eax, rewardPoints
    sub eax, pointToMoneyAmount
    mov rewardPoints, eax

    call Crlf

    mov eax, lightGreen
    call SetTextColor
    mov edx, OFFSET moneyRedeemSuccess
    call writeString

    call Crlf

    mov eax, white               ; Set label text to white
    call SetTextColor
    mov edx, OFFSET moneyRedeemMsg
    call writeString

    mov eax, yellow              ; Set values to yellow
    call SetTextColor
    mov edx, OFFSET balanceUnit
    call writeString
    mov eax, moneyRedeemAmount
    call writeDec
    call Crlf

    mov eax, white               ; Set label text to white
    call SetTextColor
    mov edx, OFFSET rewardPointsDeducted
    call writeString

    mov eax, yellow              ; Set values to yellow
    call SetTextColor
    mov eax, pointToMoneyAmount
    sub eax, leftoverPoints
    call writeDec

    mov edx, OFFSET points
    call writeString

    call Crlf

    mov eax, white               ; Set label text to white  
    call SetTextColor
    mov edx, OFFSET extraPointMsg1
    call writeString

    mov eax, leftoverPoints
    call writeDec

    mov edx, OFFSET extraPointMsg2
    call writeString

    call Crlf 

    jmp NotConfirmRedeemMoney

NotConfirmRedeemMoney:
    mov eax, white               ; Set prompt text to white
    call SetTextColor
    call ContinueRequest

    ; Handle 'Y' or 'y'
    mov al, byte ptr [continueOption] ; Load continueOption into AL
    or al, 32                    ; Convert 'Y' to 'y' (if uppercase)
    cmp al, 'y'
    je getRedeemPointsLoop       ; If 'y' (or 'Y'), go to GetRedeemPointsLoop

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je RequestReperform          ; If 'n' (or 'N'), go to RequestReperform

    ; Invalid input, re-prompt
    mov eax, lightRed                 ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf                    ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    jmp NotConfirmRedeemMoney     ; Loop back for valid input

redeemVoucherCode:
    call ClrScr

voucherMenuCodeLoop:
    mov eax, white               ; Set menu text to white
    call SetTextColor
    mov edx, OFFSET voucherCodeMenu
    call writeString

getVoucherCodeChoice:
    mov eax, white               ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET voucherCodeMsg
    call writeString

    mov eax, lightGreen          ; Set input color to light green
    call SetTextColor
    call ReadInt
    mov voucherCodeChoice, eax

    ; Validate input range (1-5)
    cmp eax, 1
    jl InvalidVoucherCodeChoce
    cmp eax, 5
    jg InvalidVoucherCodeChoce

    cmp voucherCodeChoice, 1
    je redeemVoucher

    cmp voucherCodeChoice, 2
    je redeemVoucher

    cmp voucherCodeChoice, 3
    je redeemVoucher

    cmp voucherCodeChoice, 4
    je RedeemPoints

    cmp voucherCodeChoice, 5
    je QuitProgram

InvalidVoucherCodeChoce:
    mov eax, lightRed                 ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf                    ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    call WaitMsg
    call ClrScr
    jmp voucherMenuCodeLoop      ; Loop back to re-display the menu

redeemVoucher:
makeConfirmationRedeemVoucher:
    mov eax, white               ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET confirmVoucher
    call WriteString

    ; Read user input (confirmation)
    mov eax, lightGreen          ; Set input color to light green
    call SetTextColor
    call ReadChar
    or al, 32                    ; Convert to lowercase (handles 'Y' and 'y')
    call WriteChar               ; Echo the character

    cmp al, 'y'
    je updateRewardPoints        ; If 'y', proceed to update balance

    call Crlf

    cmp al, 'n'
    je NotConfirmVoucher         ; If 'n', return to voucher menu

    ; Invalid input, re-prompt
    mov eax, lightRed                 ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf                    ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    jmp makeConfirmationRedeemVoucher

UpdateRewardPoints:
    mov eax, rewardPoints
    cmp eax, 30
    jb notEnoughPoints

    mov eax, rewardPoints
    sub eax, 30
    mov rewardPoints, eax

    call Crlf

    mov eax, lightGreen          ; Set success message to light green
    call SetTextColor
    mov edx, OFFSET voucherRedeemSuccess
    call writeString

    call Crlf

    mov eax, yellow              ; Set voucher code to yellow
    call SetTextColor
    
    cmp voucherCodeChoice, 1
    je printVoucher1Code

    cmp voucherCodeChoice, 2
    je printVoucher2Code

    cmp voucherCodeChoice, 3
    je printVoucher3Code

    jmp NotConfirmVoucher

printVoucher1Code:
    mov edx, OFFSET voucherCode1
    call writeString
    jmp NotConfirmVoucher

printVoucher2Code:
    mov edx, OFFSET voucherCode2
    call writeString
    jmp NotConfirmVoucher

printVoucher3Code:
    mov edx, OFFSET voucherCode3
    call writeString
    jmp NotConfirmVoucher

NotConfirmVoucher:
    call Crlf
    mov eax, white               ; Set prompt text to white
    call SetTextColor
    call ContinueRequest

    ; Handle 'Y' or 'y'
    mov al, byte ptr [continueOption] ; Load continueOption into AL
    or al, 32                     ; Convert 'Y' to 'y' (if uppercase)
    cmp al, 'y'
    je getVoucherCodeChoice       ; If 'y' (or 'Y'), go to getVoucherCodeChoice

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je RequestReperform           ; If 'n' (or 'N'), go to RequestReperform

    ; Invalid input, re-prompt
    mov eax, lightRed                  ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    mov eax, white
    call SetTextColor
    jmp NotConfirmVoucher         ; Loop back for valid input

notEnoughPoints:
    call Crlf
    mov eax, lightRed                  ; Set error message to red
    call SetTextColor
    mov edx, OFFSET insufficientRewardPoint
    call writeString
    call Crlf
    call Crlf                     ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    call WaitMsg
    call ClrScr
    jmp voucherMenuCodeLoop

RequestReperform:
    mov eax, white                ; Set prompt text to white
    call SetTextColor
    call RePerformFunction

    ; Handle 'Y' or 'y' to go back to main menu
    mov al, byte ptr [redoOption] ; Load redoOption into AL
    or al, 32
    cmp al, 'y'
    je DisplayMainMenu

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je QuitProgram                ; If 'n' (or 'N'), go to QuitProgram

    ; Invalid input, re-prompt
    mov eax, lightRed                  ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    jmp RequestReperform          ; Loop back for valid input

    ret
RedeemPoints ENDP

EstimateFutureRewards PROC
    call ClrScr

    mov eax, lightCyan            ; Set title to light cyan
    call SetTextColor
    mov edx, OFFSET futureEstimateTitle
    call WriteString
    call Crlf

    ; Prompt for Monthly Deposit
    mov eax, white                ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET promptMonthlyDeposit
    call WriteString
    
    mov eax, lightGreen           ; Set input color to light green
    call SetTextColor
    call ReadInt
    mov monthlyDeposit, eax       ; Store user's monthly deposit

    ; Validate monthly deposit (must be positive)
    cmp eax, 0
    jle invalidMonthlyDepositInput

getNumberOfMonths:
    ; Prompt for Number of Months
    mov eax, white                ; Set prompt text to white
    call SetTextColor
    mov edx, OFFSET promptMonths
    call WriteString
    
    mov eax, lightGreen           ; Set input color to light green
    call SetTextColor
    call ReadInt
    mov numberOfMonths, eax       ; Store number of months

    ; Validate number of months (must be positive)
    cmp eax, 0
    jle invalidMonthsInput

    ; Calculate: monthlyDeposit / 10
    mov eax, monthlyDeposit
    mov ebx, 10
    xor edx, edx
    div ebx                       ; EAX = reward points per month

    ; Multiply by numberOfMonths
    mov ebx, numberOfMonths
    mul ebx                       ; EAX = estimated future reward points

    mov estimatedPoints, eax      ; Store in variable

    ; Display result
    call Crlf
    mov eax, white                ; Set label text to white
    call SetTextColor
    mov edx, OFFSET estimatedPointsMsg
    call WriteString
    
    mov eax, yellow               ; Set result value to yellow
    call SetTextColor
    mov eax, estimatedPoints
    call WriteDec
    
    mov eax, white                ; Set unit text to white
    call SetTextColor
    mov edx, OFFSET points
    call WriteString
    call Crlf

    mov eax, white                ; Set prompt text to white
    call SetTextColor
    call ContinueRequest

    ; Handle 'Y' or 'y'
    mov al, byte ptr [continueOption] ; Load continueOption into AL
    or al, 32                     ; Convert 'Y' to 'y' (if uppercase)
    cmp al, 'y'
    je EstimateFutureRewards      ; If 'y' (or 'Y'), do another estimation

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je ChooseAnotherFunction      ; If 'n' (or 'N'), choose another function

    ; Invalid input, re-prompt
    mov eax, lightRed                  ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    jmp ContinueEstimatePrompt

invalidMonthlyDepositInput:
    mov eax, lightRed                  ; Set error message to red
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage  ; Reuse this error message
    call WriteString
    call Crlf
    call Crlf                     ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    call WaitMsg
    mov eax, white
    call SetTextColor
    jmp EstimateFutureRewards     ; Start over

invalidMonthsInput:
    mov eax, lightRed                  ; Set error message to red
    call SetTextColor
    mov edx, OFFSET invalidWithdrawMessage  ; Reuse this error message
    call WriteString
    call Crlf
    call Crlf                     ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    jmp getNumberOfMonths         ; Retry months input

ContinueEstimatePrompt:
    mov eax, white                ; Set prompt text to white
    call SetTextColor
    call ContinueRequest
    
    ; Handle 'Y' or 'y'
    mov al, byte ptr [continueOption] ; Load continueOption into AL
    or al, 32                     ; Convert 'Y' to 'y' (if uppercase)
    cmp al, 'y'
    je EstimateFutureRewards      ; If 'y' (or 'Y'), do another estimation

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je ChooseAnotherFunction      ; If 'n' (or 'N'), choose another function

    ; Invalid input, re-prompt (recursively)
    mov eax, lightRed                  ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf                     ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    jmp ContinueEstimatePrompt

ChooseAnotherFunction:
    mov eax, white                ; Set prompt text to white
    call SetTextColor
    call RePerformFunction

    ; Handle 'Y' or 'y' to go back ;----------Initial Menu----------
InitialMenu PROC
    LOCAL choice:DWORD

InitialMenuLoop:
    call Clrscr
    mov edx, OFFSET welcomeMessage
    call WriteString
    call Crlf
    call Crlf

    ; Display menu options
    mov edx, OFFSET initialMenuOptions
    call WriteString

    ; Prompt user for choice
    mov edx, OFFSET initialMenuPrompt
    call WriteString
    call ReadInt
    mov choice, eax

    ; Handle choices
    cmp choice, 1
    je Register

    cmp choice, 2
    je Login

    cmp choice, 3
    je QuitProgram

    ; Invalid input
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    jmp InitialMenuLoop

    ret
InitialMenu ENDP

;----------Register----------
Register PROC
    LOCAL username[32]:BYTE
    LOCAL cardPart1:DWORD
    LOCAL cardPart2:DWORD
    LOCAL pin:DWORD
    LOCAL balance:DWORD
    LOCAL fileHandle:DWORD
    LOCAL bytesWritten:DWORD

    call Clrscr
    mov edx, OFFSET registerPrompt
    call WriteString
    call Crlf

    ; Prompt for username
    mov edx, OFFSET usernamePrompt
    call WriteString
    call ReadString, ADDR username, 32

    ; Prompt for card number (part 1)
    mov edx, OFFSET cardPart1Prompt
    call WriteString
    call ReadInt
    mov cardPart1, eax

    ; Prompt for card number (part 2)
    mov edx, OFFSET cardPart2Prompt
    call WriteString
    call ReadInt
    mov cardPart2, eax

    ; Prompt for PIN
    mov edx, OFFSET pinPrompt
    call WriteString
    call ReadInt
    mov pin, eax

    ; Prompt for balance
    mov edx, OFFSET balancePrompt
    call WriteString
    call ReadInt
    mov balance, eax

    ; Open file for appending
    INVOKE CreateFile, ADDR fileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
    mov fileHandle, eax
    cmp fileHandle, INVALID_HANDLE_VALUE
    je RegisterFailed

    ; Move to the end of the file
    INVOKE SetFilePointer, fileHandle, 0, NULL, FILE_END

    ; Write user data to file
    lea edx, username
    call WriteToFile, fileHandle, edx, 32
    call WriteToFile, fileHandle, ADDR cardPart1, 4
    call WriteToFile, fileHandle, ADDR cardPart2, 4
    call WriteToFile, fileHandle, ADDR pin, 4
    call WriteToFile, fileHandle, ADDR balance, 4

    ; Close file
    INVOKE CloseHandle, fileHandle

    mov edx, OFFSET registerSuccess
    call WriteString
    call Crlf
    jmp InitialMenu

RegisterFailed:
    mov edx, OFFSET registerFailed
    call WriteString
    call Crlf
    jmp InitialMenu

    ret
Register ENDP

;----------Login----------
Login PROC
    LOCAL cardPart1:DWORD
    LOCAL cardPart2:DWORD
    LOCAL pin:DWORD
    LOCAL fileHandle:DWORD
    LOCAL bytesRead:DWORD
    LOCAL buffer[128]:BYTE

    call Clrscr
    mov edx, OFFSET loginPrompt
    call WriteString
    call Crlf

    ; Prompt for card number (part 1)
    mov edx, OFFSET cardPart1Prompt
    call WriteString
    call ReadInt
    mov cardPart1, eax

    ; Prompt for card number (part 2)
    mov edx, OFFSET cardPart2Prompt
    call WriteString
    call ReadInt
    mov cardPart2, eax

    ; Prompt for PIN
    mov edx, OFFSET pinPrompt
    call WriteString
    call ReadInt
    mov pin, eax

    ; Open file for reading
    INVOKE CreateFile, ADDR fileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
    mov fileHandle, eax
    cmp fileHandle, INVALID_HANDLE_VALUE
    je LoginFailed

    ; Read file content
    INVOKE ReadFile, fileHandle, ADDR buffer, SIZEOF buffer, ADDR bytesRead, NULL
    ; Now buffer contains the file content

    ; Validate credentials
    lea esi, buffer
ValidateLoop:
    ; Compare cardPart1
    mov eax, cardPart1
    cmp eax, [esi + 32]
    jne NextRecord

    ; Compare cardPart2
    mov eax, cardPart2
    cmp eax, [esi + 36]
    jne NextRecord

    ; Compare PIN
    mov eax, pin
    cmp eax, [esi + 40]
    jne NextRecord

    ; If all match, login success
    mov edx, OFFSET loginSuccess
    call WriteString
    call Crlf
    jmp DisplayMainMenu

NextRecord:
    add esi, 44 ; Move to the next record (32 bytes username + 4 bytes cardPart1 + 4 bytes cardPart2 + 4 bytes pin + 4 bytes balance)
    cmp esi, OFFSET buffer + bytesRead
    jb ValidateLoop

    ; If no match found
    mov edx, OFFSET loginFailed
    call WriteString
    call Crlf
    jmp InitialMenu

LoginFailed:
    mov edx, OFFSET loginFailed
    call WriteString
    call Crlf
    jmp InitialMenu

    ret
Login ENDP

;----------Helper Procedure to Write to File----------
WriteToFile PROC
    LOCAL fileHandle:DWORD
    LOCAL data:DWORD
    LOCAL size:DWORD
    LOCAL bytesWritten:DWORD

    mov fileHandle, ecx
    mov data, edx
    mov size, ebx

    INVOKE WriteFile, fileHandle, data, size, ADDR bytesWritten, NULL
    ret
WriteToFile ENDP

to main menu
    mov al, byte ptr [redoOption] ; Load redoOption into AL
    or al, 32
    cmp al, 'y'
    je DisplayMainMenu

    ; Handle 'N' or 'n'
    cmp al, 'n'
    je QuitProgram                ; If 'n' (or 'N'), quit program

    ; Invalid input, re-prompt
    mov eax, lightRed                  ; Set error message to red
    call SetTextColor
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    call Crlf                     ; Add extra blank line after error message
    mov eax, white
    call SetTextColor
    jmp ChooseAnotherFunction     ; Loop back for valid input

    ret
EstimateFutureRewards ENDP
QuitProgram PROC
    mov eax, white
    call SetTextColor
    call ClrScr
    mov eax, lightCyan
    call SetTextColor
    mov edx, OFFSET exitMessage
    call WriteString
    call Crlf
    call Crlf
    mov eax, white
    call SetTextColor
    call WaitMsg
   ;----------Initial Menu----------
InitialMenu PROC
    LOCAL choice:DWORD

InitialMenuLoop:
    call Clrscr
    mov edx, OFFSET welcomeMessage
    call WriteString
    call Crlf
    call Crlf

    ; Display menu options
    mov edx, OFFSET initialMenuOptions
    call WriteString

    ; Prompt user for choice
    mov edx, OFFSET initialMenuPrompt
    call WriteString
    call ReadInt
    mov choice, eax

    ; Handle choices
    cmp choice, 1
    je Register

    cmp choice, 2
    je Login

    cmp choice, 3
    je QuitProgram

    ; Invalid input
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    jmp InitialMenuLoop

    ret
InitialMenu ENDP

;----------Register----------
Register PROC
    LOCAL username[32]:BYTE
    LOCAL cardPart1:DWORD
    LOCAL cardPart2:DWORD
    LOCAL pin:DWORD
    LOCAL balance:DWORD
    LOCAL fileHandle:DWORD
    LOCAL bytesWritten:DWORD

    call Clrscr
    mov edx, OFFSET registerPrompt
    call WriteString
    call Crlf

    ; Prompt for username
    mov edx, OFFSET usernamePrompt
    call WriteString
    call ReadString, ADDR username, 32

    ; Prompt for card number (part 1)
    mov edx, OFFSET cardPart1Prompt
    call WriteString
    call ReadInt
    mov cardPart1, eax

    ; Prompt for card number (part 2)
    mov edx, OFFSET cardPart2Prompt
    call WriteString
    call ReadInt
    mov cardPart2, eax

    ; Prompt for PIN
    mov edx, OFFSET pinPrompt
    call WriteString
    call ReadInt
    mov pin, eax

    ; Prompt for balance
    mov edx, OFFSET balancePrompt
    call WriteString
    call ReadInt
    mov balance, eax

    ; Open file for appending
    INVOKE CreateFile, ADDR fileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
    mov fileHandle, eax
    cmp fileHandle, INVALID_HANDLE_VALUE
    je RegisterFailed

    ; Move to the end of the file
    INVOKE SetFilePointer, fileHandle, 0, NULL, FILE_END

    ; Write user data to file
    lea edx, username
    call WriteToFile, fileHandle, edx, 32
    call WriteToFile, fileHandle, ADDR cardPart1, 4
    call WriteToFile, fileHandle, ADDR cardPart2, 4
    call WriteToFile, fileHandle, ADDR pin, 4
    call WriteToFile, fileHandle, ADDR balance, 4

    ; Close file
    INVOKE CloseHandle, fileHandle

    mov edx, OFFSET registerSuccess
    call WriteString
    call Crlf
    jmp InitialMenu

RegisterFailed:
    mov edx, OFFSET registerFailed
    call WriteString
    call Crlf
    jmp InitialMenu

    ret
Register ENDP

;----------Login----------
Login PROC
    LOCAL cardPart1:DWORD
    LOCAL cardPart2:DWORD
    LOCAL pin:DWORD
    LOCAL fileHandle:DWORD
    LOCAL bytesRead:DWORD
    LOCAL buffer[128]:BYTE

    call Clrscr
    mov edx, OFFSET loginPrompt
    call WriteString
    call Crlf

    ; Prompt for card number (part 1)
    mov edx, OFFSET cardPart1Prompt
    call WriteString
    call ReadInt
    mov cardPart1, eax

    ; Prompt for card number (part 2)
    mov edx, OFFSET cardPart2Prompt
    call WriteString
    call ReadInt
    mov cardPart2, eax

    ; Prompt for PIN
    mov edx, OFFSET pinPrompt
    call WriteString
    call ReadInt
    mov pin, eax

    ; Open file for reading
    INVOKE CreateFile, ADDR fileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
    mov fileHandle, eax
    cmp fileHandle, INVALID_HANDLE_VALUE
    je LoginFailed

    ; Read file content
    INVOKE ReadFile, fileHandle, ADDR buffer, SIZEOF buffer, ADDR bytesRead, NULL
    ; Now buffer contains the file content

    ; Validate credentials
    lea esi, buffer
ValidateLoop:
    ; Compare cardPart1
    mov eax, cardPart1
    cmp eax, [esi + 32]
    jne NextRecord

    ; Compare cardPart2
    mov eax, cardPart2
    cmp eax, [esi + 36]
    jne NextRecord

    ; Compare PIN
    mov eax, pin
    cmp eax, [esi + 40]
    jne NextRecord

    ; If all match, login success
    mov edx, OFFSET loginSuccess
    call WriteString
    call Crlf
    jmp DisplayMainMenu

NextRecord:
    add esi, 44 ; Move to the next record (32 bytes username + 4 bytes cardPart1 + 4 bytes cardPart2 + 4 bytes pin + 4 bytes balance)
    cmp esi, OFFSET buffer + bytesRead
    jb ValidateLoop

    ; If no match found
    mov edx, OFFSET loginFailed
    call WriteString
    call Crlf
    jmp InitialMenu

LoginFailed:
    mov edx, OFFSET loginFailed
    call WriteString
    call Crlf
    jmp InitialMenu

    ret
Login ENDP

;----------Helper Procedure to Write to File----------
WriteToFile PROC
    LOCAL fileHandle:DWORD
    LOCAL data:DWORD
    LOCAL size:DWORD
    LOCAL bytesWritten:DWORD

    mov fileHandle, ecx
    mov data, edx
    mov size, ebx

    INVOKE WriteFile, fileHandle, data, size, ADDR bytesWritten, NULL
    ret
WriteToFile ENDP

 call ExitProcess
    ret
QuitProgram ENDP

;----------Redo Process----------
ContinueRequest PROC
    call Crlf
    mov edx, OFFSET continueMessage
    call writeString

    mov eax,lightGreen
    call SetTextColor
    call readChar
    mov continueOption, al

    call writeChar
    call Crlf

    ret
ContinueRequest ENDP

PrintReceiptOption PROC
    mov eax, white
    call SetTextColor
    mov edx, OFFSET printRequestMessage
    call writeString

    mov eax, lightGreen
    call SetTextColor
    call readChar
    mov printOption, al

    call writeChar
    call Crlf

    ret
PrintReceiptOption ENDP

RePerformFunction PROC
    mov eax, white
    call SetTextColor
    mov edx, OFFSET redoMessage
    call writeString

    mov eax, lightGreen
    call SetTextColor
    call readChar
    mov redoOption, al

    call writeChar
    call Crlf
    ret
RePerformFunction ENDP

;----------Initial Menu----------
InitialMenu PROC
    LOCAL choice:DWORD

InitialMenuLoop:
    call Clrscr
    mov edx, OFFSET welcomeMessage
    call WriteString
    call Crlf
    call Crlf

    ; Display menu options
    mov edx, OFFSET initialMenuOptions
    call WriteString

    ; Prompt user for choice
    mov edx, OFFSET initialMenuPrompt
    call WriteString
    call ReadInt
    mov choice, eax

    ; Handle choices
    cmp choice, 1
    je Register

    cmp choice, 2
    je Login

    cmp choice, 3
    je QuitProgram

    ; Invalid input
    mov edx, OFFSET errorMessage
    call WriteString
    call Crlf
    jmp InitialMenuLoop

    ret
InitialMenu ENDP

;----------Register----------
Register PROC
    LOCAL username[32]:BYTE
    LOCAL cardPart1:DWORD
    LOCAL cardPart2:DWORD
    LOCAL pin:DWORD
    LOCAL balance:DWORD
    LOCAL fileHandle:DWORD
    LOCAL bytesWritten:DWORD

    call Clrscr
    mov edx, OFFSET registerPrompt
    call WriteString
    call Crlf

    ; Prompt for username
    mov edx, OFFSET usernamePrompt
    call WriteString
    call ReadString, ADDR username, 32

    ; Prompt for card number (part 1)
    mov edx, OFFSET cardPart1Prompt
    call WriteString
    call ReadInt
    mov cardPart1, eax

    ; Prompt for card number (part 2)
    mov edx, OFFSET cardPart2Prompt
    call WriteString
    call ReadInt
    mov cardPart2, eax

    ; Prompt for PIN
    mov edx, OFFSET pinPrompt
    call WriteString
    call ReadInt
    mov pin, eax

    ; Prompt for balance
    mov edx, OFFSET balancePrompt
    call WriteString
    call ReadInt
    mov balance, eax

    ; Open file for appending
    INVOKE CreateFile, ADDR fileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL
    mov fileHandle, eax
    cmp fileHandle, INVALID_HANDLE_VALUE
    je RegisterFailed

    ; Move to the end of the file
    INVOKE SetFilePointer, fileHandle, 0, NULL, FILE_END

    ; Write user data to file
    lea edx, username
    call WriteToFile, fileHandle, edx, 32
    call WriteToFile, fileHandle, ADDR cardPart1, 4
    call WriteToFile, fileHandle, ADDR cardPart2, 4
    call WriteToFile, fileHandle, ADDR pin, 4
    call WriteToFile, fileHandle, ADDR balance, 4

    ; Close file
    INVOKE CloseHandle, fileHandle

    mov edx, OFFSET registerSuccess
    call WriteString
    call Crlf
    jmp InitialMenu

RegisterFailed:
    mov edx, OFFSET registerFailed
    call WriteString
    call Crlf
    jmp InitialMenu

    ret
Register ENDP

;----------Login----------
Login PROC
    LOCAL cardPart1:DWORD
    LOCAL cardPart2:DWORD
    LOCAL pin:DWORD
    LOCAL fileHandle:DWORD
    LOCAL bytesRead:DWORD
    LOCAL buffer[128]:BYTE

    call Clrscr
    mov edx, OFFSET loginPrompt
    call WriteString
    call Crlf

    ; Prompt for card number (part 1)
    mov edx, OFFSET cardPart1Prompt
    call WriteString
    call ReadInt
    mov cardPart1, eax

    ; Prompt for card number (part 2)
    mov edx, OFFSET cardPart2Prompt
    call WriteString
    call ReadInt
    mov cardPart2, eax

    ; Prompt for PIN
    mov edx, OFFSET pinPrompt
    call WriteString
    call ReadInt
    mov pin, eax

    ; Open file for reading
    INVOKE CreateFile, ADDR fileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL
    mov fileHandle, eax
    cmp fileHandle, INVALID_HANDLE_VALUE
    je LoginFailed

    ; Read file content
    INVOKE ReadFile, fileHandle, ADDR buffer, SIZEOF buffer, ADDR bytesRead, NULL
    ; Now buffer contains the file content

    ; Validate credentials
    lea esi, buffer
ValidateLoop:
    ; Compare cardPart1
    mov eax, cardPart1
    cmp eax, [esi + 32]
    jne NextRecord

    ; Compare cardPart2
    mov eax, cardPart2
    cmp eax, [esi + 36]
    jne NextRecord

    ; Compare PIN
    mov eax, pin
    cmp eax, [esi + 40]
    jne NextRecord

    ; If all match, login success
    mov edx, OFFSET loginSuccess
    call WriteString
    call Crlf
    jmp DisplayMainMenu

NextRecord:
    add esi, 44 ; Move to the next record (32 bytes username + 4 bytes cardPart1 + 4 bytes cardPart2 + 4 bytes pin + 4 bytes balance)
    cmp esi, OFFSET buffer + bytesRead
    jb ValidateLoop

    ; If no match found
    mov edx, OFFSET loginFailed
    call WriteString
    call Crlf
    jmp InitialMenu

LoginFailed:
    mov edx, OFFSET loginFailed
    call WriteString
    call Crlf
    jmp InitialMenu

    ret
Login ENDP

;----------Helper Procedure to Write to File----------
WriteToFile PROC
    LOCAL fileHandle:DWORD
    LOCAL data:DWORD
    LOCAL size:DWORD
    LOCAL bytesWritten:DWORD

    mov fileHandle, ecx
    mov data, edx
    mov size, ebx

    INVOKE WriteFile, fileHandle, data, size, ADDR bytesWritten, NULL
    ret
WriteToFile ENDP

END MAIN


